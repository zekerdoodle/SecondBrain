<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Hypertrophy Tracker</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
<style>
/* === Second Brain Theme Variables === */
:root, [data-theme="light"] {
  --bg-primary: #FAF9F7;
  --bg-secondary: #FFFFFF;
  --bg-tertiary: #F5F4F2;
  --text-primary: #1a1a1a;
  --text-secondary: #6B6B6B;
  --text-muted: #9CA3AF;
  --border-color: #E8E6E3;
  --border-hover: #D4D2CF;
  --accent-primary: #D97757;
  --accent-hover: #C4684A;
  --accent-light: #FDF4F1;
  --accent-r: 217;
  --accent-g: 119;
  --accent-b: 87;
  --success: #10B981;
  --warning: #F59E0B;
  --error: #EF4444;
  --sp-xs: 4px; --sp-sm: 8px; --sp-md: 12px; --sp-lg: 16px; --sp-xl: 20px; --sp-2xl: 24px;
  --radius-sm: 4px; --radius-md: 8px; --radius-lg: 10px; --radius-xl: 12px; --radius-2xl: 16px; --radius-full: 9999px;
  --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --font-mono: 'SF Mono', 'Fira Code', monospace;
  --font-size-xs: 11px; --font-size-sm: 12px; --font-size-base: 13px; --font-size-md: 14px;
  --font-size-lg: 16px; --font-size-xl: 18px; --font-size-2xl: 22px;
  --ease-fast: 0.15s ease; --ease-normal: 0.2s ease; --ease-slow: 0.3s ease;
  --z-base: 1; --z-sticky: 50; --z-modal: 200; --z-toast: 300;
}

[data-theme="dark"] {
  --bg-primary: #1a1a1a;
  --bg-secondary: #242424;
  --bg-tertiary: #2d2d2d;
  --text-primary: #f5f5f5;
  --text-secondary: #a0a0a0;
  --text-muted: #6b6b6b;
  --border-color: #3d3d3d;
  --border-hover: #4d4d4d;
  --success: #34D399;
  --warning: #FBBF24;
  --error: #F87171;
}

/* === Base Reset & Typography === */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: var(--font-sans);
  font-size: var(--font-size-md);
  line-height: 1.5;
  color: var(--text-primary);
  background: var(--bg-primary);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  overflow-x: hidden;
}

::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: var(--radius-full); }
::-webkit-scrollbar-thumb:hover { background: var(--border-hover); }

/* === Cards === */
.card {
  background: var(--bg-tertiary);
  border-radius: var(--radius-xl);
  padding: var(--sp-lg);
  border: 1px solid var(--border-color);
}
.card-header {
  font-size: var(--font-size-md);
  font-weight: 600;
  margin-bottom: var(--sp-md);
  color: var(--text-secondary);
}

/* === Buttons === */
.btn {
  display: inline-flex; align-items: center; justify-content: center; gap: var(--sp-sm);
  padding: 10px 20px; border-radius: var(--radius-lg); border: none; cursor: pointer;
  font-size: var(--font-size-md); font-weight: 600; font-family: inherit;
  transition: background var(--ease-normal), opacity var(--ease-normal); user-select: none;
}
.btn:disabled { opacity: 0.5; cursor: not-allowed; }
.btn-primary { background: var(--accent-primary); color: var(--bg-secondary); }
.btn-primary:hover:not(:disabled) { background: var(--accent-hover); }
.btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); }
.btn-secondary:hover:not(:disabled) { background: var(--border-color); }
.btn-success { background: var(--success); color: var(--bg-secondary); }
.btn-success:hover:not(:disabled) { opacity: 0.9; }
.btn-danger { background: var(--error); color: var(--bg-secondary); }
.btn-danger:hover:not(:disabled) { opacity: 0.9; }
.btn-ghost { background: transparent; color: var(--text-secondary); }
.btn-ghost:hover:not(:disabled) { background: var(--bg-tertiary); color: var(--text-primary); }
.btn-sm { padding: 6px 12px; font-size: var(--font-size-sm); border-radius: var(--radius-md); }

/* === Form Inputs === */
input[type="text"], input[type="number"], input[type="email"], input[type="password"],
input[type="search"], input[type="url"], select, textarea {
  width: 100%; padding: var(--sp-md) var(--sp-lg);
  background: var(--bg-primary); color: var(--text-primary);
  border: 1px solid var(--border-color); border-radius: var(--radius-lg);
  font-size: var(--font-size-base); font-family: inherit; outline: none;
  transition: border-color var(--ease-normal);
}
input:focus, select:focus, textarea:focus { border-color: var(--accent-primary); }
input:disabled, select:disabled, textarea:disabled { opacity: 0.5; cursor: not-allowed; }
textarea { resize: vertical; min-height: 80px; }
.field { margin-bottom: 14px; }
.field label { display: block; font-size: var(--font-size-sm); font-weight: 600; color: var(--text-secondary); margin-bottom: var(--sp-xs); }
.field .hint { font-size: var(--font-size-xs); color: var(--text-muted); margin-top: 2px; }

/* === Modal === */
.modal-overlay {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0, 0, 0, 0.7); z-index: var(--z-modal);
  display: flex; align-items: center; justify-content: center; padding: var(--sp-lg);
  opacity: 0; pointer-events: none; transition: opacity var(--ease-normal);
}
.modal-overlay.show { opacity: 1; pointer-events: auto; }
.modal {
  background: var(--bg-tertiary); border-radius: var(--radius-2xl); padding: var(--sp-2xl);
  width: 100%; max-width: 400px; border: 1px solid var(--border-color);
}
.modal-title { font-size: var(--font-size-xl); font-weight: 700; }
.modal-subtitle { font-size: var(--font-size-base); color: var(--text-muted); }

/* === Toast === */
.toast {
  position: fixed; top: var(--sp-lg); left: 50%;
  transform: translateX(-50%) translateY(-100px);
  background: var(--bg-tertiary); color: var(--text-primary);
  padding: var(--sp-md) var(--sp-xl); border-radius: var(--radius-lg);
  font-size: var(--font-size-base); font-weight: 600;
  z-index: var(--z-toast); border: 1px solid var(--border-color);
  transition: transform var(--ease-slow); pointer-events: none;
}
.toast.show { transform: translateX(-50%) translateY(0); }
.toast.error { border-color: var(--error); color: var(--error); }
.toast.success { border-color: var(--success); color: var(--success); }
.toast.warning { border-color: var(--warning); color: var(--warning); }

/* === Alerts === */
.alert {
  padding: var(--sp-md) var(--sp-lg); border-radius: var(--radius-lg);
  margin-bottom: var(--sp-md); font-size: var(--font-size-base); border: 1px solid;
}
.alert-info    { background: rgba(var(--accent-r),var(--accent-g),var(--accent-b),0.1); border-color: rgba(var(--accent-r),var(--accent-g),var(--accent-b),0.3); color: var(--accent-primary); }
.alert-success { background: rgba(16,185,129,0.1); border-color: rgba(16,185,129,0.3); color: var(--success); }
.alert-warning { background: rgba(245,158,11,0.1); border-color: rgba(245,158,11,0.3); color: var(--warning); }
.alert-danger  { background: rgba(239,68,68,0.1); border-color: rgba(239,68,68,0.3); color: var(--error); }

/* === Toggle === */
.toggle {
  width: 42px; height: 24px; border-radius: var(--radius-full);
  background: var(--border-color); position: relative; cursor: pointer;
  transition: background var(--ease-normal); border: none; flex-shrink: 0;
}
.toggle.on { background: var(--accent-primary); }
.toggle::after {
  content: ''; position: absolute; top: 3px; left: 3px;
  width: 18px; height: 18px; border-radius: 50%;
  background: var(--text-primary); transition: transform var(--ease-normal);
}
.toggle.on::after { transform: translateX(18px); }

/* === Empty State === */
.empty-state { text-align: center; padding: 48px var(--sp-2xl); color: var(--text-muted); }
.empty-state .empty-icon { font-size: 48px; margin-bottom: var(--sp-md); }
.empty-state .empty-title { font-size: var(--font-size-xl); font-weight: 700; color: var(--text-secondary); margin-bottom: var(--sp-sm); }
.empty-state .empty-subtitle { font-size: var(--font-size-base); }

/* === Utilities (from theme.css) === */
.text-primary   { color: var(--text-primary); }
.text-accent    { color: var(--accent-primary); }
.text-success   { color: var(--success); }
.text-warning   { color: var(--warning); }
.text-danger    { color: var(--error); }
.font-mono { font-family: var(--font-mono); }
.font-bold { font-weight: 700; }
.flex-col { flex-direction: column; }
.items-center { align-items: center; }
.justify-between { justify-content: space-between; }
.justify-center { justify-content: center; }
.gap-xs { gap: var(--sp-xs); }
.gap-sm { gap: var(--sp-sm); }
.gap-md { gap: var(--sp-md); }
.gap-lg { gap: var(--sp-lg); }
.mb-sm { margin-bottom: var(--sp-sm); }
.mb-md { margin-bottom: var(--sp-md); }
.mb-lg { margin-bottom: var(--sp-lg); }
@keyframes slideIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
.animate-slide-in { animation: slideIn 0.2s ease-out; }
.animate-fade-in  { animation: fadeIn 0.2s ease-out; }

/* === Hypertrophy Tracker — app-specific styles === */

body {
  min-height: 100vh;
  padding-bottom: 70px;
}
/* === TAB NAV (bottom) === */
.tab-bar {
  display: flex; background: var(--bg-secondary); border-top: 1px solid var(--bg-tertiary);
  position: fixed; bottom: 0; left: 0; right: 0; z-index: var(--z-sticky);
}
.tab-btn {
  flex: 1; padding: 10px 4px 8px; text-align: center; cursor: pointer;
  color: var(--text-muted); font-size: var(--font-size-xs); font-weight: 600;
  letter-spacing: 0.3px; border: none; background: none; font-family: inherit;
  border-top: 2px solid transparent; transition: color var(--ease-normal), border-color var(--ease-normal);
  display: flex; flex-direction: column; align-items: center; gap: 3px;
}
.tab-btn:hover { color: var(--text-secondary); }
.tab-btn.active { color: var(--accent-primary); border-top-color: var(--accent-primary); }
.tab-icon { font-size: 18px; }

/* === MAIN CONTENT === */
main { padding: var(--sp-lg); max-width: 600px; margin: 0 auto; }
.tab-content { display: none; }
.tab-content.active { display: block; }

/* === CARD OVERRIDES === */
.card { margin-bottom: var(--sp-md); }
.card-header { color: var(--text-primary); font-size: 15px; }
.card-sub { font-size: var(--font-size-sm); color: var(--text-muted); }
.card-clickable { cursor: pointer; transition: all var(--ease-fast); -webkit-tap-highlight-color: transparent; }
.card-clickable:hover { border-color: var(--border-hover); }
.card-clickable:active { transform: scale(0.98); }

/* === BUTTON OVERRIDES === */
.btn { -webkit-tap-highlight-color: transparent; }
.btn-warning { background: var(--warning); color: var(--bg-secondary); }
.btn-warning:hover:not(:disabled) { opacity: 0.9; }
.btn-large { padding: 16px 28px; font-size: var(--font-size-lg); width: 100%; }
.btn-small { padding: 8px 14px; font-size: var(--font-size-sm); }
.btn-ghost { padding: 8px 12px; font-size: var(--font-size-sm); border: none; }
.btn-row { display: flex; gap: var(--sp-sm); margin-top: var(--sp-md); }

/* === INPUT OVERRIDES === */
input, select, textarea { font-size: 15px; -webkit-appearance: none; }
input[type="number"] { -moz-appearance: textfield; }
input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button { -webkit-appearance: none; }
textarea { min-height: 60px; }
label { font-size: var(--font-size-base); color: var(--text-secondary); font-weight: 600; display: block; margin-bottom: 6px; }
.form-group { margin-bottom: var(--sp-lg); }
.form-row { display: flex; gap: 10px; }
.form-row > * { flex: 1; }

/* === STAT BADGES === */
.stat-row { display: flex; gap: 10px; margin-bottom: var(--sp-md); flex-wrap: wrap; }
.stat-badge {
  flex: 1; min-width: 80px; background: var(--bg-primary); border-radius: var(--radius-lg);
  padding: var(--sp-md); text-align: center; border: 1px solid var(--border-color);
}
.stat-value { font-size: var(--font-size-2xl); font-weight: 700; color: var(--accent-primary); }
.stat-label { font-size: var(--font-size-xs); color: var(--text-muted); margin-top: 2px; }

/* === BADGES === */
.badge {
  display: inline-block; padding: 4px 10px; border-radius: var(--radius-sm); font-size: var(--font-size-xs);
  font-weight: 600; letter-spacing: 0.3px; text-transform: uppercase;
}
.badge-primary { background: rgba(var(--accent-r),var(--accent-g),var(--accent-b),0.15); color: var(--accent-primary); }
.badge-secondary { background: rgba(16,185,129,0.15); color: var(--success); }
.badge-maintenance { background: rgba(245,158,11,0.15); color: var(--warning); }
.badge-active { background: rgba(var(--accent-r),var(--accent-g),var(--accent-b),0.2); color: var(--accent-primary); }
.badge-completed { background: rgba(16,185,129,0.2); color: var(--success); }
.badge-upcoming { background: rgba(156,163,175,0.2); color: var(--text-muted); }
.badge-danger { background: rgba(239,68,68,0.15); color: var(--error); }

/* === CHIP SELECT === */
.chip-group { display: flex; flex-wrap: wrap; gap: var(--sp-sm); }
.chip {
  padding: 8px 16px; border-radius: var(--radius-full); border: 1px solid var(--border-color);
  background: var(--bg-primary); color: var(--text-secondary); font-size: var(--font-size-base); font-weight: 500;
  cursor: pointer; transition: all var(--ease-fast); -webkit-tap-highlight-color: transparent;
}
.chip:hover { border-color: var(--accent-primary); color: var(--accent-primary); }
.chip.selected { background: var(--accent-primary); color: var(--bg-secondary); border-color: var(--accent-primary); }
.chip-sm { padding: 5px 12px; font-size: var(--font-size-sm); }

/* === PRIORITY SELECT === */
.priority-select { display: flex; gap: 6px; }
.priority-opt {
  flex: 1; padding: 8px; text-align: center; border-radius: var(--radius-md);
  border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-muted);
  font-size: var(--font-size-sm); font-weight: 600; cursor: pointer; transition: all var(--ease-fast);
}
.priority-opt:hover { border-color: var(--border-hover); }
.priority-opt.sel-primary { background: rgba(var(--accent-r),var(--accent-g),var(--accent-b),0.2); color: var(--accent-primary); border-color: var(--accent-primary); }
.priority-opt.sel-secondary { background: rgba(16,185,129,0.2); color: var(--success); border-color: var(--success); }
.priority-opt.sel-maintenance { background: rgba(245,158,11,0.2); color: var(--warning); border-color: var(--warning); }

/* === WIZARD STEPPER === */
.wizard-steps { display: flex; gap: 4px; margin-bottom: 20px; padding: 0 4px; }
.wizard-step {
  flex: 1; height: 4px; border-radius: 2px; background: var(--border-color);
  transition: background var(--ease-slow);
}
.wizard-step.done { background: var(--success); }
.wizard-step.current { background: var(--accent-primary); }
.wizard-title { font-size: 20px; font-weight: 700; margin-bottom: 4px; }
.wizard-subtitle { font-size: var(--font-size-base); color: var(--text-muted); margin-bottom: 20px; }

/* === SESSION CARD === */
.session-card {
  background: var(--bg-tertiary); border-radius: var(--radius-xl); padding: 14px 16px;
  margin-bottom: 10px; border: 2px solid var(--border-color); cursor: pointer;
  transition: all var(--ease-fast);
}
.session-card:hover { border-color: var(--border-hover); }
.session-card.active-session { border-color: var(--accent-primary); }
.session-card.completed-session { border-color: var(--success); opacity: 0.8; }
.session-card-title { font-size: var(--font-size-md); font-weight: 600; margin-bottom: 4px; }
.session-card-groups { font-size: var(--font-size-sm); color: var(--text-muted); }

/* === WORKOUT VIEW === */
.workout-header {
  background: var(--bg-secondary); border-radius: var(--radius-xl); padding: var(--sp-lg);
  margin-bottom: var(--sp-lg); border: 1px solid var(--bg-tertiary);
}
.workout-title { font-size: var(--font-size-xl); font-weight: 700; }
.workout-subtitle { font-size: var(--font-size-base); color: var(--text-muted); margin-top: 4px; }

.muscle-group-section { margin-bottom: 20px; }
.muscle-group-header {
  display: flex; align-items: center; justify-content: space-between; gap: var(--sp-sm); margin-bottom: var(--sp-md);
  padding-bottom: var(--sp-sm); border-bottom: 1px solid var(--border-color);
}
.muscle-group-name { font-size: var(--font-size-lg); font-weight: 700; }

.exercise-block { margin-bottom: var(--sp-lg); }

/* Reorder buttons */
.reorder-btn {
  background: transparent;
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  color: var(--text-muted);
  width: 28px;
  height: 28px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 14px;
  padding: 0;
  transition: background var(--ease-fast), color var(--ease-fast);
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}
.reorder-btn:hover { background: var(--bg-tertiary); color: var(--text-primary); }
.reorder-btn:disabled { opacity: 0.2; cursor: default; }
.reorder-btn:disabled:hover { background: transparent; color: var(--text-muted); }
.reorder-btns { display: flex; gap: 2px; margin-right: 4px; }

/* === SUPERSET GROUPING === */
.superset-group {
  border: 2px solid var(--accent-primary);
  border-radius: var(--radius-xl);
  padding: var(--sp-sm) var(--sp-md);
  margin-bottom: var(--sp-lg);
  position: relative;
  background: rgba(var(--accent-r), var(--accent-g), var(--accent-b), 0.04);
}
.superset-group .exercise-block {
  margin-bottom: var(--sp-xs);
}
.superset-group .exercise-block:last-child {
  margin-bottom: 0;
}
.superset-label {
  display: inline-block;
  font-size: var(--font-size-xs);
  font-weight: 700;
  color: var(--accent-primary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  padding: 2px 8px;
  background: rgba(var(--accent-r), var(--accent-g), var(--accent-b), 0.12);
  border-radius: var(--radius-sm);
  margin-bottom: var(--sp-xs);
}
.superset-divider {
  height: 1px;
  background: rgba(var(--accent-r), var(--accent-g), var(--accent-b), 0.25);
  margin: var(--sp-xs) 0;
}

.exercise-header {
  display: flex; align-items: center; justify-content: space-between;
  margin-bottom: var(--sp-sm); padding: var(--sp-sm) 0;
}
.exercise-name { font-size: var(--font-size-md); font-weight: 600; }
.exercise-meta { font-size: var(--font-size-xs); color: var(--text-muted); }

.exercise-notes-toggle {
  display: inline-flex; align-items: center; gap: 3px;
  font-size: var(--font-size-xs); color: var(--text-muted);
  cursor: pointer; border: none; background: none; padding: 2px 0;
  font-family: inherit;
}
.exercise-notes-toggle:hover { color: var(--text-secondary); }
.exercise-notes-toggle.has-notes { color: var(--accent-primary); }
.exercise-notes-area {
  margin-top: var(--sp-xs);
  margin-bottom: var(--sp-sm);
}
.exercise-notes-area textarea {
  width: 100%; min-height: 50px; max-height: 120px;
  padding: var(--sp-sm); font-size: var(--font-size-xs);
  resize: vertical; border-radius: var(--radius-md);
  background: var(--bg-primary); border: 1px solid var(--border-color);
  color: var(--text-primary); font-family: inherit;
}
.exercise-notes-area textarea:focus { border-color: var(--accent-primary); outline: none; }

.set-row {
  display: flex; align-items: center; gap: 6px; margin-bottom: 6px; padding: 6px 8px;
  background: var(--bg-primary); border-radius: var(--radius-md); border: 1px solid var(--border-color);
}
.set-num { width: 28px; font-size: var(--font-size-sm); color: var(--text-muted); font-weight: 600; text-align: center; flex-shrink: 0; }
.set-input {
  width: 60px; padding: 8px; text-align: center; font-size: var(--font-size-md); font-weight: 600;
  border-radius: var(--radius-sm); background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary);
}
.set-input:focus { border-color: var(--accent-primary); outline: none; }
.set-input-label { font-size: 10px; color: var(--border-hover); text-align: center; }
.set-target { font-size: var(--font-size-xs); color: var(--border-hover); text-align: center; }
.set-col { display: flex; flex-direction: column; align-items: center; gap: 2px; }
.set-done-wrap { flex-shrink: 0; display: flex; align-items: center; justify-content: center; width: 28px; }
.set-done-cb {
  appearance: none; -webkit-appearance: none; width: 22px; height: 22px;
  border: 2px solid var(--border-hover); border-radius: var(--radius-sm); background: var(--bg-primary);
  cursor: pointer; position: relative; transition: all var(--ease-fast);
}
.set-done-cb:checked { background: var(--success); border-color: var(--success); }
.set-done-cb:checked::after {
  content: '\2713'; position: absolute; top: 50%; left: 50%;
  transform: translate(-50%, -50%); font-size: 14px; color: var(--bg-primary); font-weight: 700;
}
.set-row.set-completed { border-color: var(--success); opacity: 0.75; }
.set-type-select {
  font-size: var(--font-size-xs); padding: 2px 4px; background: var(--bg-tertiary);
  border: 1px solid var(--border-color); color: var(--text-primary); border-radius: var(--radius-sm);
  cursor: pointer; max-width: 72px;
}
.set-type-select:focus { border-color: var(--accent-primary); outline: none; }
.set-type-badge {
  font-size: 9px; padding: 1px 5px; border-radius: 3px; font-weight: 600;
  text-transform: uppercase; letter-spacing: 0.5px; white-space: nowrap;
}
.set-type-badge.myorep { background: rgba(139,92,246,0.13); color: #8B5CF6; }
.set-type-badge.myorep_match { background: rgba(236,72,153,0.13); color: #EC4899; }
.set-type-badge.giant { background: rgba(249,115,22,0.13); color: #F97316; }
.set-type-badge.straight { background: rgba(156,163,175,0.27); color: var(--text-muted); }
.set-row.set-completed .set-input { background: var(--bg-primary); color: var(--text-muted); }

/* === MODAL OVERRIDES === */
.modal-subtitle { margin-bottom: 20px; }
.modal-options { display: flex; flex-direction: column; gap: var(--sp-sm); }
.modal-opt {
  padding: 14px 16px; border-radius: var(--radius-lg); border: 1px solid var(--border-color);
  background: var(--bg-primary); color: var(--text-primary); font-size: var(--font-size-md); font-weight: 500;
  cursor: pointer; transition: all var(--ease-fast); text-align: center;
}
.modal-opt:hover { border-color: var(--accent-primary); background: rgba(var(--accent-r),var(--accent-g),var(--accent-b),0.08); }
.modal-opt.selected { border-color: var(--accent-primary); background: rgba(var(--accent-r),var(--accent-g),var(--accent-b),0.15); color: var(--accent-primary); }

/* Alerts, toasts, and empty states are inlined above */
/* === EMPTY STATE OVERRIDES === */
.empty-icon { font-size: 48px; margin-bottom: var(--sp-md); }
.empty-text { font-size: var(--font-size-base); margin-bottom: 20px; line-height: 1.5; }

/* === SEARCH === */
.search-wrap { position: relative; margin-bottom: var(--sp-md); }
.search-wrap input { padding-left: 40px; }
.search-icon { position: absolute; left: 14px; top: 50%; transform: translateY(-50%); color: var(--text-muted); font-size: var(--font-size-md); }

/* === WEEK NAV === */
.week-nav {
  display: flex; align-items: center; justify-content: space-between;
  margin-bottom: var(--sp-lg); padding: var(--sp-sm) 0;
}
.week-nav-label { font-size: var(--font-size-lg); font-weight: 700; }
.week-nav-btn {
  background: var(--bg-tertiary); border: none; color: var(--text-primary); width: 36px; height: 36px;
  border-radius: var(--radius-md); cursor: pointer; font-size: var(--font-size-lg); display: flex;
  align-items: center; justify-content: center; transition: background var(--ease-fast);
}
.week-nav-btn:hover { background: var(--border-hover); }
.week-nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }

/* === SWAP SUGGESTION === */
.swap-suggestion {
  background: rgba(245,158,11,0.1); border: 1px solid rgba(245,158,11,0.3);
  border-radius: var(--radius-lg); padding: var(--sp-md); margin-top: var(--sp-sm);
  font-size: var(--font-size-base);
}
.swap-suggestion.urgent {
  background: rgba(239,68,68,0.1); border-color: rgba(239,68,68,0.3);
}

/* === HISTORY CHART === */
.chart-container { position: relative; height: 250px; margin: var(--sp-lg) 0; }

/* === DELOAD BANNER === */
.deload-banner {
  background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.3);
  border-radius: var(--radius-xl); padding: var(--sp-lg); margin-bottom: var(--sp-lg); text-align: center;
}
.deload-banner .deload-icon { font-size: 32px; margin-bottom: var(--sp-sm); }
.deload-banner .deload-title { font-size: var(--font-size-lg); font-weight: 700; color: var(--error); }
.deload-banner .deload-text { font-size: var(--font-size-base); color: var(--text-secondary); margin-top: 4px; }

/* === MISC === */
.divider { height: 1px; background: var(--border-color); margin: var(--sp-lg) 0; }
.text-muted { color: var(--text-muted); }
.text-sm { font-size: var(--font-size-sm); }
.text-center { text-align: center; }
.mt-4 { margin-top: 4px; }
.mt-8 { margin-top: 8px; }
.mt-12 { margin-top: 12px; }
.mt-16 { margin-top: 16px; }
.mb-4 { margin-bottom: 4px; }
.mb-8 { margin-bottom: 8px; }
.mb-12 { margin-bottom: 12px; }
.mb-16 { margin-bottom: 16px; }
.gap-8 { gap: var(--sp-sm); }
.flex { display: flex; }
.flex-between { display: flex; justify-content: space-between; align-items: center; }
.fade-in { animation: fadeIn 0.2s ease; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
.hidden { display: none !important; }

/* === EDIT CONTROLS === */
.edit-btn {
  background: none; border: none; color: var(--text-muted); cursor: pointer;
  font-size: var(--font-size-md); padding: 4px 8px; transition: color var(--ease-fast);
  -webkit-tap-highlight-color: transparent;
}
.edit-btn:hover { color: var(--accent-primary); }
.edit-item {
  background: var(--bg-primary); border-radius: var(--radius-lg); padding: var(--sp-md); margin-bottom: var(--sp-sm);
  border: 1px solid var(--border-color);
}
.edit-item .flex-between { align-items: flex-start; }
.edit-item-actions { display: flex; gap: 4px; align-items: center; flex-shrink: 0; }
.modal-scroll { max-height: 70vh; overflow-y: auto; }
.confirm-delete { color: var(--error); font-size: var(--font-size-sm); margin-top: var(--sp-sm); }
</style>
<script>
// Second Brain Theme Bridge — reads parent app's theme from localStorage
(function() {
  const STORAGE_KEY = 'second-brain-theme';
  const defaults = { mode: 'light', accentColor: '#D97757', accentHover: '#C4684A' };

  function hexToRgb(hex) {
    const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return r ? { r: parseInt(r[1],16), g: parseInt(r[2],16), b: parseInt(r[3],16) } : null;
  }

  function applyTheme() {
    let prefs = defaults;
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) prefs = { ...defaults, ...JSON.parse(stored) };
    } catch(e) {}

    let mode = prefs.mode;
    if (mode === 'system') {
      mode = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }

    document.documentElement.setAttribute('data-theme', mode);
    document.documentElement.style.setProperty('--accent-primary', prefs.accentColor);
    document.documentElement.style.setProperty('--accent-hover', prefs.accentHover);

    const rgb = hexToRgb(prefs.accentColor);
    if (rgb) {
      document.documentElement.style.setProperty('--accent-r', rgb.r);
      document.documentElement.style.setProperty('--accent-g', rgb.g);
      document.documentElement.style.setProperty('--accent-b', rgb.b);
    }

    const accentLight = prefs.accentColor + '15';
    document.documentElement.style.setProperty('--accent-light', accentLight);
  }

  applyTheme();

  // Listen for storage changes (if user changes theme while app is open)
  window.addEventListener('storage', function(e) {
    if (e.key === STORAGE_KEY) applyTheme();
  });

  // Listen for system theme changes
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', applyTheme);
})();
</script>
</head>
<body>

<!-- Toast Notification -->
<div id="toast" class="toast"></div>

<!-- Modal Overlay -->
<div id="modal-overlay" class="modal-overlay" onclick="if(event.target===this)closeModal()">
  <div class="modal" id="modal-content"></div>
</div>

<!-- Tab Content -->
<main>
  <div id="tab-dashboard" class="tab-content active"></div>
  <div id="tab-builder" class="tab-content"></div>
  <div id="tab-workout" class="tab-content"></div>
  <div id="tab-history" class="tab-content"></div>
  <div id="tab-exercises" class="tab-content"></div>
</main>

<!-- Bottom Tab Bar -->
<div class="tab-bar">
  <button class="tab-btn active" data-tab="dashboard">
    <span class="tab-icon">&#127968;</span>Home
  </button>
  <button class="tab-btn" data-tab="builder">
    <span class="tab-icon">&#128295;</span>Builder
  </button>
  <button class="tab-btn" data-tab="workout">
    <span class="tab-icon">&#128170;</span>Workout
  </button>
  <button class="tab-btn" data-tab="history">
    <span class="tab-icon">&#128200;</span>History
  </button>
  <button class="tab-btn" data-tab="exercises">
    <span class="tab-icon">&#128218;</span>Exercises
  </button>
</div>

<script>
// ============================================================
// DATA LAYER
// ============================================================
const DATA_PATH = 'hypertrophy/';
let exerciseLib = { exercises: [] };
let mesocycles = [];
let history = [];
let activeMesoId = null;
let currentTab = 'dashboard';

// Wizard state
let wizard = { step: 0, meso: null };

// Workout state
let activeWorkout = null; // { mesoId, microIdx, sessionIdx }

// History view state
let historyExercise = null;

// Microcycle view state
let viewingWeek = 0;

async function readJSON(file) {
  try {
    const raw = await window.brain.readFile(DATA_PATH + file);
    if (!raw || raw.trim() === '') return null;
    return JSON.parse(raw);
  } catch (e) { console.error('Read error:', file, e); return null; }
}

async function writeJSON(file, data) {
  try {
    await window.brain.writeFile(DATA_PATH + file, JSON.stringify(data, null, 2));
  } catch (e) { console.error('Write error:', file, e); toast('Failed to save', 'error'); }
}

async function loadAll() {
  const [ex, meso, hist] = await Promise.all([
    readJSON('exercises.json'),
    readJSON('mesocycles.json'),
    readJSON('history.json')
  ]);
  exerciseLib = ex || { exercises: [] };
  mesocycles = meso || [];
  history = hist || [];
}

async function saveMesocycles() { await writeJSON('mesocycles.json', mesocycles); }
async function saveHistory() { await writeJSON('history.json', history); }
async function saveExercises() { await writeJSON('exercises.json', exerciseLib); }

function uid() { return Date.now().toString(36) + Math.random().toString(36).slice(2, 8); }

function toast(msg, type = '') {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.className = 'toast show' + (type ? ' ' + type : '');
  setTimeout(() => el.className = 'toast', 2500);
}

function roundTo5(n) { return Math.round(n / 5) * 5; }

function resolveMyoParent(sets, idx) {
  // Walk upward from idx to find the parent set for a myorep_match
  for (let i = idx - 1; i >= 0; i--) {
    const t = sets[i].setType || 'straight';
    if (t !== 'myorep_match') return sets[i];
  }
  return sets[0]; // Fallback
}

// ============================================================
// TAB NAVIGATION
// ============================================================
document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
    currentTab = btn.dataset.tab;
    renderCurrentTab();
  });
});

function switchTab(tab) {
  document.querySelectorAll('.tab-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.tab === tab);
  });
  document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
  document.getElementById('tab-' + tab).classList.add('active');
  currentTab = tab;
  renderCurrentTab();
}

function renderCurrentTab() {
  switch (currentTab) {
    case 'dashboard': renderDashboard(); break;
    case 'builder': renderBuilder(); break;
    case 'workout': renderWorkout(); break;
    case 'history': renderHistory(); break;
    case 'exercises': renderExercises(); break;
  }
}

// ============================================================
// MODAL SYSTEM
// ============================================================
function showModal(html) {
  document.getElementById('modal-content').innerHTML = html;
  document.getElementById('modal-overlay').classList.add('show');
}

function closeModal() {
  document.getElementById('modal-overlay').classList.remove('show');
}

// ============================================================
// HELPER: Get active mesocycle
// ============================================================
function getActiveMeso() {
  return mesocycles.find(m => m.status === 'active') || null;
}

function getActiveMicro(meso) {
  if (!meso) return null;
  return meso.microcycles.find(mc => mc.status === 'active') || null;
}

function getNextSession(meso) {
  const micro = getActiveMicro(meso);
  if (!micro) return null;
  return micro.sessions.find(s => s.status !== 'completed') || null;
}

function getMuscleGroups() {
  const groups = new Set();
  exerciseLib.exercises.forEach(e => groups.add(e.muscleGroup));
  return Array.from(groups).sort();
}

function getExercisesForGroup(group) {
  return exerciseLib.exercises.filter(e => e.muscleGroup === group);
}

// ============================================================
// DASHBOARD
// ============================================================
function renderDashboard() {
  const area = document.getElementById('tab-dashboard');
  const meso = getActiveMeso();

  if (mesocycles.length === 0) {
    area.innerHTML = `
      <div class="empty-state fade-in">
        <div class="empty-icon">&#128170;</div>
        <div class="empty-title">No Mesocycles Yet</div>
        <div class="empty-text">Create your first mesocycle to start tracking your hypertrophy training with smart progression.</div>
        <button class="btn btn-primary btn-large" onclick="startNewMeso()">Create Mesocycle</button>
      </div>
    `;
    return;
  }

  let html = '<div class="fade-in">';

  // Active mesocycle summary
  if (meso) {
    const micro = getActiveMicro(meso);
    const nextSess = getNextSession(meso);
    const completedSessions = meso.microcycles.reduce((sum, mc) =>
      sum + mc.sessions.filter(s => s.status === 'completed').length, 0);
    const totalSessions = meso.microcycles.reduce((sum, mc) => sum + mc.sessions.length, 0);

    html += `
      <div class="workout-header mb-16">
        <div class="flex-between">
          <div>
            <div class="workout-title">${esc(meso.name)}</div>
            <div class="workout-subtitle">
              ${micro ? `Week ${micro.weekNumber}` : 'Starting'} &middot; RPE ${micro ? micro.targetRPE : meso.startingRPE}
            </div>
          </div>
          <span class="badge badge-active">Active</span>
        </div>
        <div class="stat-row mt-12">
          <div class="stat-badge">
            <div class="stat-value">${micro ? micro.weekNumber : 1}</div>
            <div class="stat-label">Week</div>
          </div>
          <div class="stat-badge">
            <div class="stat-value">${completedSessions}/${totalSessions}</div>
            <div class="stat-label">Sessions</div>
          </div>
          <div class="stat-badge">
            <div class="stat-value">${meso.microcycles.length}</div>
            <div class="stat-label">Weeks</div>
          </div>
        </div>
        ${nextSess ? `
          <button class="btn btn-success btn-large mt-8" onclick="startSession('${meso.id}', ${meso.microcycles.indexOf(micro)}, ${micro.sessions.indexOf(nextSess)})">
            Start: ${esc(nextSess.dayLabel)}
          </button>
        ` : `
          <div class="alert alert-success mt-8">All sessions for this week are complete!</div>
        `}
      </div>
    `;
  }

  // New meso button
  html += `<button class="btn btn-primary btn-large mb-16" onclick="startNewMeso()">+ New Mesocycle</button>`;

  // All mesocycles list
  html += `<div class="card-header mb-8">All Mesocycles</div>`;
  mesocycles.forEach(m => {
    const totalWeeks = m.microcycles.length;
    const completedWeeks = m.microcycles.filter(mc => mc.status === 'completed').length;
    html += `
      <div class="card card-clickable" onclick="viewMesocycle('${m.id}')">
        <div class="flex-between">
          <div>
            <div class="card-header" style="margin-bottom:2px">${esc(m.name)}</div>
            <div class="card-sub">${totalWeeks} week${totalWeeks !== 1 ? 's' : ''} &middot; ${completedWeeks} completed &middot; RPE ${m.startingRPE}</div>
          </div>
          <div style="display:flex;align-items:center;gap:6px;">
            <button class="edit-btn" onclick="event.stopPropagation();editMesocycle('${m.id}')" title="Edit">&#9998;</button>
            <span class="badge badge-${m.status === 'active' ? 'active' : 'completed'}">${m.status}</span>
          </div>
        </div>
      </div>
    `;
  });

  html += '</div>';
  area.innerHTML = html;
}

function viewMesocycle(mesoId) {
  activeMesoId = mesoId;
  const meso = mesocycles.find(m => m.id === mesoId);
  if (!meso) return;
  const micro = getActiveMicro(meso);
  viewingWeek = micro ? meso.microcycles.indexOf(micro) : 0;
  switchTab('workout');
}

function startNewMeso() {
  wizard = {
    step: 0,
    meso: {
      id: uid(),
      name: '',
      startingRPE: 7,
      status: 'active',
      createdAt: new Date().toISOString(),
      microcycles: [{
        id: uid(),
        weekNumber: 1,
        targetRPE: 7,
        sessions: [],
        status: 'active'
      }]
    }
  };
  switchTab('builder');
}

// ============================================================
// MESOCYCLE BUILDER (Wizard)
// ============================================================
const WIZARD_STEPS = ['Name & RPE', 'Sessions', 'Muscle Groups', 'Exercises', 'Review'];

function renderBuilder() {
  const area = document.getElementById('tab-builder');
  if (!wizard.meso) {
    area.innerHTML = `
      <div class="empty-state fade-in">
        <div class="empty-icon">&#128295;</div>
        <div class="empty-title">Mesocycle Builder</div>
        <div class="empty-text">Start building a new mesocycle from the Dashboard.</div>
        <button class="btn btn-primary btn-large" onclick="startNewMeso()">Create Mesocycle</button>
      </div>
    `;
    return;
  }

  let html = '<div class="fade-in">';

  // Step indicator
  html += '<div class="wizard-steps">';
  for (let i = 0; i < WIZARD_STEPS.length; i++) {
    const cls = i < wizard.step ? 'done' : i === wizard.step ? 'current' : '';
    html += `<div class="wizard-step ${cls}"></div>`;
  }
  html += '</div>';

  switch (wizard.step) {
    case 0: html += renderWizardStep0(); break;
    case 1: html += renderWizardStep1(); break;
    case 2: html += renderWizardStep2(); break;
    case 3: html += renderWizardStep3(); break;
    case 4: html += renderWizardStep4(); break;
  }

  html += '</div>';
  area.innerHTML = html;
}

function renderWizardStep0() {
  const m = wizard.meso;
  return `
    <div class="wizard-title">Name & Starting RPE</div>
    <div class="wizard-subtitle">Give your mesocycle a name and set the starting difficulty.</div>
    <div class="form-group">
      <label>Mesocycle Name</label>
      <input type="text" id="wiz-name" value="${esc(m.name)}" placeholder="e.g. Spring Bulk, Push/Pull/Legs">
    </div>
    <div class="form-group">
      <label>Starting RPE (Week 1)</label>
      <input type="number" id="wiz-rpe" value="${m.startingRPE}" min="5" max="10" step="0.5"
        style="font-size:20px; text-align:center; max-width:120px;">
      <div class="text-sm text-muted mt-8">Typically 6-7 for most lifters. This increases each week based on priority.</div>
    </div>
    <div class="btn-row">
      <button class="btn btn-secondary" onclick="wizard.meso=null; switchTab('dashboard')">Cancel</button>
      <button class="btn btn-primary" onclick="wizNext0()" style="flex:2">Next &rarr;</button>
    </div>
  `;
}

function wizNext0() {
  const name = document.getElementById('wiz-name').value.trim();
  const rpe = parseFloat(document.getElementById('wiz-rpe').value) || 7;
  if (!name) { toast('Enter a name'); return; }
  wizard.meso.name = name;
  wizard.meso.startingRPE = rpe;
  wizard.meso.microcycles[0].targetRPE = rpe;
  wizard.step = 1;
  renderBuilder();
}

function renderWizardStep1() {
  const sessions = wizard.meso.microcycles[0].sessions;
  let html = `
    <div class="wizard-title">Sessions</div>
    <div class="wizard-subtitle">How many workouts per week? Name each one.</div>
  `;

  if (sessions.length === 0) {
    html += `
      <div class="form-group">
        <label>Number of Sessions</label>
        <div class="chip-group">
          ${[2,3,4,5,6,7].map(n => `<div class="chip" onclick="initSessions(${n})">${n}</div>`).join('')}
        </div>
      </div>
    `;
  } else {
    sessions.forEach((s, i) => {
      html += `
        <div class="form-group">
          <label>Session ${i + 1}</label>
          <input type="text" class="wiz-session-name" data-idx="${i}" value="${esc(s.dayLabel)}" placeholder="e.g. Push A, Upper Body, Legs">
        </div>
      `;
    });
    html += `
      <div class="btn-row">
        <button class="btn btn-ghost" onclick="initSessions(0)">Reset</button>
        <button class="btn btn-secondary" onclick="wizard.step=0; renderBuilder()">&larr; Back</button>
        <button class="btn btn-primary" onclick="wizNext1()" style="flex:2">Next &rarr;</button>
      </div>
    `;
  }
  return html;
}

function initSessions(n) {
  if (n === 0) {
    wizard.meso.microcycles[0].sessions = [];
    renderBuilder();
    return;
  }
  const sessions = [];
  for (let i = 0; i < n; i++) {
    sessions.push({
      id: uid(),
      dayLabel: `Day ${i + 1}`,
      muscleGroups: [],
      status: 'upcoming',
      completedAt: null
    });
  }
  wizard.meso.microcycles[0].sessions = sessions;
  renderBuilder();
}

function wizNext1() {
  const inputs = document.querySelectorAll('.wiz-session-name');
  inputs.forEach(inp => {
    const idx = parseInt(inp.dataset.idx);
    const val = inp.value.trim();
    if (val) wizard.meso.microcycles[0].sessions[idx].dayLabel = val;
  });
  wizard.step = 2;
  renderBuilder();
}

function renderWizardStep2() {
  const sessions = wizard.meso.microcycles[0].sessions;
  const groups = getMuscleGroups();

  let html = `
    <div class="wizard-title">Muscle Groups</div>
    <div class="wizard-subtitle">Assign muscle groups to each session and set their priority.</div>
  `;

  sessions.forEach((s, si) => {
    html += `
      <div class="card mb-12">
        <div class="card-header">${esc(s.dayLabel)}</div>
    `;

    // Show assigned groups
    s.muscleGroups.forEach((mg, gi) => {
      html += `
        <div class="flex-between mb-8" style="padding:6px 0;">
          <span style="font-size:14px;font-weight:500;">${esc(mg.muscleGroup)}</span>
          <div style="display:flex;align-items:center;gap:6px;">
            <div class="priority-select">
              <div class="priority-opt ${mg.priority === 'primary' ? 'sel-primary' : ''}"
                onclick="setGroupPriority(${si},${gi},'primary')">P</div>
              <div class="priority-opt ${mg.priority === 'secondary' ? 'sel-secondary' : ''}"
                onclick="setGroupPriority(${si},${gi},'secondary')">S</div>
              <div class="priority-opt ${mg.priority === 'maintenance' ? 'sel-maintenance' : ''}"
                onclick="setGroupPriority(${si},${gi},'maintenance')">M</div>
            </div>
            <button class="btn-ghost" onclick="removeGroup(${si},${gi})" style="color:var(--error);font-size:16px;">&times;</button>
          </div>
        </div>
      `;
    });

    // Add group button
    html += `
        <div class="chip-group mt-8" style="flex-wrap:wrap;">
          ${groups.filter(g => !s.muscleGroups.find(mg => mg.muscleGroup === g)).map(g =>
            `<div class="chip chip-sm" onclick="addGroup(${si},'${esc(g)}')">${esc(g)}</div>`
          ).join('')}
        </div>
      </div>
    `;
  });

  html += `
    <div class="btn-row">
      <button class="btn btn-secondary" onclick="wizard.step=1; renderBuilder()">&larr; Back</button>
      <button class="btn btn-primary" onclick="wizNext2()" style="flex:2">Next &rarr;</button>
    </div>
  `;
  return html;
}

function addGroup(si, group) {
  wizard.meso.microcycles[0].sessions[si].muscleGroups.push({
    muscleGroup: group,
    priority: 'primary',
    soreness: null,
    exercises: []
  });
  renderBuilder();
}

function removeGroup(si, gi) {
  wizard.meso.microcycles[0].sessions[si].muscleGroups.splice(gi, 1);
  renderBuilder();
}

function setGroupPriority(si, gi, priority) {
  wizard.meso.microcycles[0].sessions[si].muscleGroups[gi].priority = priority;
  renderBuilder();
}

function wizNext2() {
  const sessions = wizard.meso.microcycles[0].sessions;
  const hasGroups = sessions.some(s => s.muscleGroups.length > 0);
  if (!hasGroups) { toast('Add at least one muscle group'); return; }
  wizard.step = 3;
  renderBuilder();
}

function renderWizardStep3() {
  const sessions = wizard.meso.microcycles[0].sessions;

  let html = `
    <div class="wizard-title">Exercises & Sets</div>
    <div class="wizard-subtitle">Pick exercises, set rep ranges, and starting loads for Week 1.</div>
  `;

  sessions.forEach((s, si) => {
    if (s.muscleGroups.length === 0) return;
    html += `<div class="card mb-12"><div class="card-header mb-12">${esc(s.dayLabel)}</div>`;

    s.muscleGroups.forEach((mg, gi) => {
      const available = getExercisesForGroup(mg.muscleGroup);
      html += `
        <div class="muscle-group-section">
          <div class="muscle-group-header">
            <span class="muscle-group-name">${esc(mg.muscleGroup)}</span>
            <span class="badge badge-${mg.priority}">${mg.priority}</span>
          </div>
      `;

      // List assigned exercises
      mg.exercises.forEach((ex, ei) => {
        html += `
          <div class="exercise-block" style="background:var(--bg-primary);border-radius:var(--radius-lg);padding:12px;margin-bottom:8px;border:1px solid var(--border-color);">
            <div class="flex-between mb-8">
              <span class="exercise-name">${esc(ex.name)}</span>
              <button class="btn-ghost" onclick="removeExercise(${si},${gi},${ei})" style="color:var(--error);">&times;</button>
            </div>
        `;

        ex.sets.forEach((set, setIdx) => {
          const sType = set.setType || 'straight';
          const aboveType = setIdx > 0 ? (ex.sets[setIdx - 1]?.setType || 'straight') : '';
          const canMyoMatch = setIdx > 0 && (aboveType === 'straight' || aboveType === 'myorep_match');
          const isMyoMatch = sType === 'myorep_match';
          const myoParent = isMyoMatch ? resolveMyoParent(ex.sets, setIdx) : null;
          html += `
            <div class="set-row">
              <div class="set-num">${setIdx + 1}</div>
              <div class="set-col">
                <div class="set-input-label">Type</div>
                <select class="set-type-select" onchange="updateSetType(${si},${gi},${ei},${setIdx},this.value)">
                  <option value="straight" ${sType === 'straight' ? 'selected' : ''}>Straight</option>
                  <option value="myorep" ${sType === 'myorep' ? 'selected' : ''}>Myorep</option>
                  ${canMyoMatch ? `<option value="myorep_match" ${sType === 'myorep_match' ? 'selected' : ''}>Myo Match</option>` : ''}
                  <option value="giant" ${sType === 'giant' ? 'selected' : ''}>Giant</option>
                </select>
              </div>
              <div class="set-col">
                <div class="set-input-label">Reps</div>
                <div style="display:flex;gap:4px;align-items:center;">
                  <input type="number" class="set-input" style="width:45px;" value="${isMyoMatch ? (myoParent?.repRange[0] || set.repRange[0]) : set.repRange[0]}"
                    onchange="updateSetRange(${si},${gi},${ei},${setIdx},0,this.value)" ${isMyoMatch ? 'disabled style="width:45px;opacity:0.5;"' : ''}>
                  <span style="color:var(--text-muted);">-</span>
                  <input type="number" class="set-input" style="width:45px;" value="${isMyoMatch ? (myoParent?.repRange[1] || set.repRange[1]) : set.repRange[1]}"
                    onchange="updateSetRange(${si},${gi},${ei},${setIdx},1,this.value)" ${isMyoMatch ? 'disabled style="width:45px;opacity:0.5;"' : ''}>
                </div>
              </div>
              <div class="set-col">
                <div class="set-input-label">Load</div>
                <input type="number" class="set-input" value="${isMyoMatch ? (myoParent?.targetLoad || set.targetLoad) : set.targetLoad}"
                  onchange="updateSetLoad(${si},${gi},${ei},${setIdx},this.value)" ${isMyoMatch ? 'disabled style="opacity:0.5;"' : ''}>
              </div>
              <button class="btn-ghost" onclick="removeSet(${si},${gi},${ei},${setIdx})" style="color:var(--error);font-size:14px;">&times;</button>
            </div>
          `;
        });

        html += `
            <button class="btn btn-ghost mt-8" onclick="addSet(${si},${gi},${ei})">+ Add Set</button>
          </div>
        `;
      });

      // Add exercise selector
      const unassigned = available.filter(a => !mg.exercises.find(e => e.exerciseId === a.id));
      if (unassigned.length > 0) {
        html += `
          <div style="margin-top:8px;">
            <select onchange="addExercise(${si},${gi},this.value);this.value='';" style="font-size:13px;padding:8px 12px;">
              <option value="">+ Add Exercise...</option>
              ${unassigned.map(e => `<option value="${e.id}">${esc(e.name)}</option>`).join('')}
            </select>
          </div>
        `;
      }

      // Inline add new exercise
      html += `
        <div style="margin-top:6px;display:flex;gap:6px;">
          <input type="text" id="new-ex-${si}-${gi}" placeholder="New exercise name..." style="font-size:12px;padding:8px;">
          <button class="btn btn-secondary btn-small" onclick="addNewExercise(${si},${gi})">Add</button>
        </div>
      `;

      if (mg.exercises.length >= 2) {
        const hasSuperset = mg.exercises.some(e => e.supersetGroup);
        html += `
          <button class="btn btn-ghost btn-small mt-8" onclick="promptWizardSuperset(${si},${gi})" style="color:var(--accent-primary);">
            ${hasSuperset ? '&#128279; Edit Superset' : '&#9878; Link as Superset'}
          </button>
        `;
      }

      html += `</div>`; // muscle-group-section
    });

    html += `</div>`; // card
  });

  html += `
    <div class="btn-row">
      <button class="btn btn-secondary" onclick="wizard.step=2; renderBuilder()">&larr; Back</button>
      <button class="btn btn-primary" onclick="wizNext3()" style="flex:2">Next &rarr;</button>
    </div>
  `;
  return html;
}

function addExercise(si, gi, exId) {
  if (!exId) return;
  const ex = exerciseLib.exercises.find(e => e.id === exId);
  if (!ex) return;
  wizard.meso.microcycles[0].sessions[si].muscleGroups[gi].exercises.push({
    exerciseId: ex.id,
    name: ex.name,
    muscleGroup: ex.muscleGroup,
    supersetGroup: null,
    jointPainHistory: [],
    sets: [{ repRange: [8, 12], targetLoad: 0, targetReps: 8, targetRPE: wizard.meso.startingRPE, setType: 'straight' }]
  });
  renderBuilder();
}

function addNewExercise(si, gi) {
  const input = document.getElementById(`new-ex-${si}-${gi}`);
  const name = input.value.trim();
  if (!name) return;
  const mg = wizard.meso.microcycles[0].sessions[si].muscleGroups[gi].muscleGroup;
  const newEx = { id: uid(), name, muscleGroup: mg, notes: '' };
  exerciseLib.exercises.push(newEx);
  saveExercises();
  wizard.meso.microcycles[0].sessions[si].muscleGroups[gi].exercises.push({
    exerciseId: newEx.id,
    name: newEx.name,
    muscleGroup: newEx.muscleGroup,
    supersetGroup: null,
    jointPainHistory: [],
    sets: [{ repRange: [8, 12], targetLoad: 0, targetReps: 8, targetRPE: wizard.meso.startingRPE, setType: 'straight' }]
  });
  renderBuilder();
}

function removeExercise(si, gi, ei) {
  wizard.meso.microcycles[0].sessions[si].muscleGroups[gi].exercises.splice(ei, 1);
  renderBuilder();
}

function addSet(si, gi, ei) {
  const ex = wizard.meso.microcycles[0].sessions[si].muscleGroups[gi].exercises[ei];
  const lastSet = ex.sets[ex.sets.length - 1] || { repRange: [8, 12], targetLoad: 0, targetReps: 8, targetRPE: wizard.meso.startingRPE, setType: 'straight' };
  ex.sets.push({ ...lastSet, repRange: [...lastSet.repRange], setType: lastSet.setType || 'straight' });
  renderBuilder();
}

function removeSet(si, gi, ei, setIdx) {
  const ex = wizard.meso.microcycles[0].sessions[si].muscleGroups[gi].exercises[ei];
  if (ex.sets.length <= 1) { toast('Need at least 1 set'); return; }
  ex.sets.splice(setIdx, 1);
  renderBuilder();
}

function updateSetRange(si, gi, ei, setIdx, which, val) {
  wizard.meso.microcycles[0].sessions[si].muscleGroups[gi].exercises[ei].sets[setIdx].repRange[which] = parseInt(val) || 0;
}

function updateSetLoad(si, gi, ei, setIdx, val) {
  const set = wizard.meso.microcycles[0].sessions[si].muscleGroups[gi].exercises[ei].sets[setIdx];
  set.targetLoad = parseFloat(val) || 0;
  set.targetReps = set.repRange[0]; // Start at bottom of range
}

function updateSetType(si, gi, ei, setIdx, val) {
  const ex = wizard.meso.microcycles[0].sessions[si].muscleGroups[gi].exercises[ei];
  ex.sets[setIdx].setType = val;
  // If changing to a type that can't parent a myorep_match, reset any below
  if (val !== 'straight' && val !== 'myorep_match') {
    for (let i = setIdx + 1; i < ex.sets.length; i++) {
      if (ex.sets[i].setType === 'myorep_match') ex.sets[i].setType = 'straight';
      else break;
    }
  }
  // If setting to myorep_match, sync with resolved parent
  if (val === 'myorep_match' && setIdx > 0) {
    const parent = resolveMyoParent(ex.sets, setIdx);
    ex.sets[setIdx].repRange = [...parent.repRange];
    ex.sets[setIdx].targetLoad = parent.targetLoad;
    ex.sets[setIdx].targetReps = parent.targetReps;
  }
  renderBuilder();
}

function wizNext3() {
  const sessions = wizard.meso.microcycles[0].sessions;
  const hasExercises = sessions.some(s => s.muscleGroups.some(mg => mg.exercises.length > 0));
  if (!hasExercises) { toast('Add at least one exercise'); return; }
  wizard.step = 4;
  renderBuilder();
}

function renderWizardStep4() {
  const meso = wizard.meso;
  const sessions = meso.microcycles[0].sessions;

  let html = `
    <div class="wizard-title">Review Mesocycle</div>
    <div class="wizard-subtitle">Everything look good? Hit create to start training.</div>
    <div class="card mb-12">
      <div class="card-header">${esc(meso.name)}</div>
      <div class="card-sub">Starting RPE: ${meso.startingRPE} &middot; ${sessions.length} sessions/week</div>
    </div>
  `;

  sessions.forEach(s => {
    html += `<div class="card mb-12"><div class="card-header mb-8">${esc(s.dayLabel)}</div>`;
    s.muscleGroups.forEach(mg => {
      html += `
        <div style="margin-bottom:8px;">
          <div class="flex-between mb-4">
            <span style="font-weight:600;font-size:13px;">${esc(mg.muscleGroup)}</span>
            <span class="badge badge-${mg.priority}">${mg.priority}</span>
          </div>
      `;
      mg.exercises.forEach(ex => {
        const typeAbbrev = { straight: '', myorep: ' Myo', myorep_match: ' M.M', giant: ' Giant' };
        const setsInfo = ex.sets.map((s, i) => `Set ${i+1}${typeAbbrev[s.setType || 'straight']}: ${s.targetLoad}lbs × ${s.repRange[0]}-${s.repRange[1]}`).join(', ');
        html += `<div class="text-sm text-muted" style="padding-left:8px;margin-bottom:2px;">${esc(ex.name)} — ${ex.sets.length} set${ex.sets.length > 1 ? 's' : ''} (${setsInfo})</div>`;
      });
      html += `</div>`;
    });
    html += `</div>`;
  });

  html += `
    <div class="btn-row">
      <button class="btn btn-secondary" onclick="wizard.step=3; renderBuilder()">&larr; Back</button>
      <button class="btn btn-success" onclick="createMesocycle()" style="flex:2">Create Mesocycle &#10003;</button>
    </div>
  `;
  return html;
}

async function createMesocycle() {
  // Deactivate any existing active meso
  mesocycles.forEach(m => { if (m.status === 'active') m.status = 'completed'; });

  // Set target reps/RPE for all sets in week 1
  const micro = wizard.meso.microcycles[0];
  micro.sessions.forEach(s => {
    s.muscleGroups.forEach(mg => {
      const rpe = getRPEForPriority(mg.priority, wizard.meso.startingRPE, 1);
      mg.exercises.forEach(ex => {
        ex.sets.forEach(set => {
          set.targetReps = set.repRange[0];
          set.targetRPE = rpe;
        });
      });
    });
  });

  mesocycles.push(wizard.meso);
  await saveMesocycles();
  wizard = { step: 0, meso: null };
  toast('Mesocycle created!', 'success');
  switchTab('dashboard');
}

// ============================================================
// WORKOUT VIEW (Session + Microcycle combined)
// ============================================================
function renderWorkout() {
  const area = document.getElementById('tab-workout');
  const meso = activeMesoId ? mesocycles.find(m => m.id === activeMesoId) : getActiveMeso();

  if (!meso) {
    area.innerHTML = `
      <div class="empty-state fade-in">
        <div class="empty-icon">&#128170;</div>
        <div class="empty-title">No Active Mesocycle</div>
        <div class="empty-text">Create a mesocycle from the Dashboard to start working out.</div>
        <button class="btn btn-primary btn-large" onclick="switchTab('dashboard')">Go to Dashboard</button>
      </div>
    `;
    return;
  }

  // If there's an active workout session, show the session view
  if (activeWorkout && activeWorkout.mesoId === meso.id) {
    renderSessionView(area, meso);
    return;
  }

  // Otherwise show microcycle overview
  renderMicrocycleView(area, meso);
}

function renderMicrocycleView(area, meso) {
  const weekIdx = Math.max(0, Math.min(viewingWeek, meso.microcycles.length - 1));
  const micro = meso.microcycles[weekIdx];
  if (!micro) return;

  // Determine max viewable week (current active + 1, per spec)
  const activeIdx = meso.microcycles.findIndex(mc => mc.status === 'active');
  const maxViewable = Math.min(activeIdx + 1, meso.microcycles.length - 1);

  let html = '<div class="fade-in">';

  // Header with meso name
  html += `
    <div class="workout-header">
      <div class="flex-between">
        <div>
          <div class="workout-title">${esc(meso.name)}</div>
          <div class="workout-subtitle">${meso.microcycles.length} week mesocycle &middot; RPE ${meso.startingRPE} start</div>
        </div>
        <button class="edit-btn" onclick="editMesocycle('${meso.id}')" title="Edit mesocycle" style="font-size:18px;">&#9998;</button>
      </div>
    </div>
  `;

  // Week nav
  html += `
    <div class="week-nav">
      <button class="week-nav-btn" onclick="navWeek(-1)" ${weekIdx <= 0 ? 'disabled' : ''}>&laquo;</button>
      <div>
        <div class="week-nav-label">Week ${micro.weekNumber}</div>
        <div class="text-sm text-muted text-center">RPE ${micro.targetRPE}</div>
      </div>
      <button class="week-nav-btn" onclick="navWeek(1)" ${weekIdx >= maxViewable ? 'disabled' : ''}>&raquo;</button>
    </div>
  `;

  // Deload suggestion banners (dismissable, §3.1.1)
  micro.sessions.forEach(s => {
    s.muscleGroups.forEach(mg => {
      mg.exercises.forEach(ex => {
        if (ex._deload === 'suggested') {
          html += `
            <div class="deload-banner" id="deload-banner-${ex.exerciseId}">
              <div class="deload-icon">&#9888;</div>
              <div class="deload-title">Deload Suggested</div>
              <div class="deload-text">${esc(ex.name)} has been below expectations 2 weeks in a row. Consider reducing load.</div>
              <div class="btn-row" style="justify-content:center;margin-top:12px;">
                <button class="btn btn-secondary btn-small" onclick="dismissDeload('${ex.exerciseId}')">Dismiss</button>
                <button class="btn btn-warning btn-small" onclick="applyDeload('${meso.id}',${weekIdx},'${ex.exerciseId}')">Apply Deload</button>
              </div>
            </div>
          `;
        }
      });
    });
  });

  // Session cards
  micro.sessions.forEach((s, si) => {
    const statusCls = s.status === 'completed' ? 'completed-session' : s.status === 'active' ? 'active-session' : '';
    const groups = s.muscleGroups.map(mg => mg.muscleGroup).join(', ');
    const icon = s.status === 'completed' ? '&#10003;' : s.status === 'active' ? '&#9654;' : '&#9711;';

    html += `
      <div class="session-card ${statusCls}" onclick="startSession('${meso.id}', ${weekIdx}, ${si})">
        <div class="flex-between">
          <div>
            <div class="session-card-title">${icon} ${esc(s.dayLabel)}</div>
            <div class="session-card-groups">${esc(groups) || 'No muscle groups'}</div>
          </div>
          <div style="display:flex;align-items:center;gap:6px;">
            <button class="edit-btn" onclick="event.stopPropagation();editSession('${meso.id}',${weekIdx},${si})" title="Edit session">&#9998;</button>
            <span class="badge badge-${s.status === 'completed' ? 'completed' : s.status === 'active' ? 'active' : 'upcoming'}">${s.status}</span>
          </div>
        </div>
        ${s.completedAt ? `<div class="text-sm text-muted mt-8">Completed ${new Date(s.completedAt).toLocaleDateString()}</div>` : ''}
      </div>
    `;
  });

  // Add session button
  html += `<button class="btn btn-secondary" style="width:100%;margin-top:8px;" onclick="addSessionToMicrocycle('${meso.id}',${weekIdx})">+ Add Session</button>`;

  // Complete mesocycle button (if all weeks done)
  const allDone = meso.microcycles.every(mc => mc.status === 'completed');
  if (allDone) {
    html += `
      <div class="divider"></div>
      <button class="btn btn-warning btn-large" onclick="completeMesocycle('${meso.id}')">Complete Mesocycle</button>
    `;
  }

  html += '</div>';
  area.innerHTML = html;
}

function navWeek(delta) {
  viewingWeek += delta;
  renderWorkout();
}

function dismissDeload(exId) {
  const el = document.getElementById('deload-banner-' + exId);
  if (el) el.remove();
}

async function applyDeload(mesoId, microIdx, exId) {
  const meso = mesocycles.find(m => m.id === mesoId);
  const micro = meso.microcycles[microIdx];
  micro.sessions.forEach(s => {
    s.muscleGroups.forEach(mg => {
      mg.exercises.forEach(ex => {
        if (ex.exerciseId === exId) {
          ex.sets.forEach(s => {
            const st = s.setType || 'straight';
            if (st === 'myorep_match') return;
            if (st !== 'giant') s.targetLoad = roundTo5(s.targetLoad * 0.9);
            s.targetReps = s.repRange[0];
          });
          // Sync myorep_match with resolved parent
          ex.sets.forEach((s, i) => {
            if (i > 0 && (s.setType || 'straight') === 'myorep_match') {
              const parent = resolveMyoParent(ex.sets, i);
              if (parent) { s.targetLoad = parent.targetLoad; s.targetReps = parent.targetReps; }
            }
          });
          ex._deload = 'forced';
        }
      });
    });
  });
  await saveMesocycles();
  dismissDeload(exId);
  toast('Deload applied — load reduced 10%', 'warning');
  renderWorkout();
}

function startSession(mesoId, microIdx, sessionIdx) {
  activeWorkout = { mesoId, microIdx, sessionIdx };
  activeMesoId = mesoId;
  viewingWeek = microIdx;
  const meso = mesocycles.find(m => m.id === mesoId);
  const session = meso.microcycles[microIdx].sessions[sessionIdx];
  session.status = 'active';
  saveMesocycles();
  switchTab('workout');
}

// === SUPERSET HELPERS ===
function groupExercisesBySupersets(exercises) {
  const groups = [];
  const used = new Set();
  exercises.forEach((ex, idx) => {
    if (used.has(idx)) return;
    if (ex.supersetGroup) {
      const members = [];
      exercises.forEach((e2, i2) => {
        if (e2.supersetGroup === ex.supersetGroup) {
          members.push({ exercise: e2, originalIndex: i2 });
          used.add(i2);
        }
      });
      groups.push({ type: 'superset', groupId: ex.supersetGroup, members });
    } else {
      used.add(idx);
      groups.push({ type: 'single', exercise: ex, originalIndex: idx });
    }
  });
  return groups;
}

function createSuperset(mesoId, microIdx, sessionIdx, mgIdx, exerciseIndices) {
  const meso = mesocycles.find(m => m.id === mesoId);
  if (!meso) return;
  const mg = meso.microcycles[microIdx].sessions[sessionIdx].muscleGroups[mgIdx];
  const groupId = uid();
  exerciseIndices.forEach(ei => { mg.exercises[ei].supersetGroup = groupId; });
  saveMesocycles();
}

function removeFromSuperset(mesoId, microIdx, sessionIdx, mgIdx, exIdx) {
  const meso = mesocycles.find(m => m.id === mesoId);
  if (!meso) return;
  const mg = meso.microcycles[microIdx].sessions[sessionIdx].muscleGroups[mgIdx];
  const ex = mg.exercises[exIdx];
  const oldGroup = ex.supersetGroup;
  ex.supersetGroup = null;
  // If only one exercise left in the group, remove its supersetGroup too
  const remaining = mg.exercises.filter(e => e.supersetGroup === oldGroup);
  if (remaining.length === 1) remaining[0].supersetGroup = null;
  saveMesocycles();
}

function promptSuperset(mesoId, microIdx, sessionIdx, mgIdx, exIdx) {
  const meso = mesocycles.find(m => m.id === mesoId);
  if (!meso) return;
  const mg = meso.microcycles[microIdx].sessions[sessionIdx].muscleGroups[mgIdx];
  const ex = mg.exercises[exIdx];

  if (ex.supersetGroup) {
    // Already in a superset — offer to remove
    showModal(`
      <div class="modal-title">Superset</div>
      <div class="modal-subtitle"><strong>${esc(ex.name)}</strong> is in a superset.</div>
      <div class="modal-options">
        <div class="modal-opt" onclick="removeFromSuperset('${mesoId}',${microIdx},${sessionIdx},${mgIdx},${exIdx}); closeModal(); renderWorkout();">Remove from Superset</div>
      </div>
      <button class="btn btn-ghost mt-12" onclick="closeModal()" style="width:100%">Cancel</button>
    `);
    return;
  }

  // Show other exercises in same muscle group to link with
  const others = mg.exercises.map((e, i) => ({ ex: e, idx: i })).filter(o => o.idx !== exIdx);
  if (others.length === 0) {
    toast('Need at least 2 exercises to create a superset');
    return;
  }

  let optionsHtml = others.map(o => {
    const inSuperset = o.ex.supersetGroup ? ' (in superset)' : '';
    return `<div class="modal-opt" onclick="createSuperset('${mesoId}',${microIdx},${sessionIdx},${mgIdx},[${exIdx},${o.idx}]); closeModal(); renderWorkout();">${esc(o.ex.name)}${inSuperset}</div>`;
  }).join('');

  showModal(`
    <div class="modal-title">Create Superset</div>
    <div class="modal-subtitle">Superset <strong>${esc(ex.name)}</strong> with:</div>
    <div class="modal-options">${optionsHtml}</div>
    <button class="btn btn-ghost mt-12" onclick="closeModal()" style="width:100%">Cancel</button>
  `);
}

function promptWizardSuperset(si, gi) {
  const mg = wizard.meso.microcycles[0].sessions[si].muscleGroups[gi];
  if (mg.exercises.length < 2) {
    toast('Need at least 2 exercises to create a superset');
    return;
  }

  // Multi-select: pick which exercises to group
  let html = `
    <div class="modal-title">Link as Superset</div>
    <div class="modal-subtitle">Select exercises to superset together in <strong>${esc(mg.muscleGroup)}</strong>:</div>
    <div style="margin:12px 0;">
  `;
  mg.exercises.forEach((ex, ei) => {
    const checked = ex.supersetGroup ? 'checked' : '';
    html += `<label style="display:flex;align-items:center;gap:8px;padding:8px 0;border-bottom:1px solid var(--border-color);cursor:pointer;font-weight:400;">
      <input type="checkbox" class="wizard-ss-cb" value="${ei}" ${checked} style="width:18px;height:18px;">
      ${esc(ex.name)}
    </label>`;
  });
  html += `</div>
    <div class="btn-row">
      <button class="btn btn-ghost" onclick="clearWizardSuperset(${si},${gi}); closeModal(); renderBuilder();">Clear All</button>
      <button class="btn btn-primary" onclick="applyWizardSuperset(${si},${gi})" style="flex:2">Apply</button>
    </div>
    <button class="btn btn-ghost mt-8" onclick="closeModal()" style="width:100%">Cancel</button>
  `;
  showModal(html);
}

function applyWizardSuperset(si, gi) {
  const checkboxes = document.querySelectorAll('.wizard-ss-cb:checked');
  const indices = Array.from(checkboxes).map(cb => parseInt(cb.value));
  const mg = wizard.meso.microcycles[0].sessions[si].muscleGroups[gi];

  // Clear all supersetGroups in this muscle group first
  mg.exercises.forEach(ex => { ex.supersetGroup = null; });

  if (indices.length >= 2) {
    const groupId = uid();
    indices.forEach(i => { mg.exercises[i].supersetGroup = groupId; });
  }

  closeModal();
  renderBuilder();
}

function clearWizardSuperset(si, gi) {
  const mg = wizard.meso.microcycles[0].sessions[si].muscleGroups[gi];
  mg.exercises.forEach(ex => { ex.supersetGroup = null; });
}

function renderSessionView(area, meso) {
  const { microIdx, sessionIdx } = activeWorkout;
  const micro = meso.microcycles[microIdx];
  const session = micro.sessions[sessionIdx];

  let html = '<div class="fade-in">';

  // Header
  html += `
    <div class="workout-header">
      <div class="flex-between">
        <div>
          <div class="workout-title">${esc(session.dayLabel)}</div>
          <div class="workout-subtitle">Week ${micro.weekNumber} &middot; Target RPE ${micro.targetRPE}</div>
        </div>
        <div style="display:flex;gap:6px;">
          <button class="btn btn-secondary btn-small" onclick="editSession('${meso.id}',${microIdx},${sessionIdx})">Edit</button>
          <button class="btn btn-secondary btn-small" onclick="exitSession()">Back</button>
        </div>
      </div>
    </div>
  `;

  // Soreness prompts needed? Check if there are muscle groups that appeared in a prior session
  const sorenessNeeded = session.muscleGroups.filter(mg => mg.soreness === null && needsSorenessPrompt(meso, microIdx, sessionIdx, mg.muscleGroup));
  if (sorenessNeeded.length > 0) {
    html += `<div class="alert alert-info mb-12">Tap a muscle group below to log soreness from your last session.</div>`;
    sorenessNeeded.forEach(mg => {
      html += `
        <div class="card card-clickable mb-8" onclick="promptSoreness('${esc(mg.muscleGroup)}')">
          <div class="flex-between">
            <span style="font-weight:600;">${esc(mg.muscleGroup)}</span>
            <span class="badge badge-upcoming">Needs soreness</span>
          </div>
        </div>
      `;
    });
    html += `<div class="divider"></div>`;
  }

  // Exercise blocks
  session.muscleGroups.forEach((mg, mgIdx) => {
    html += `
      <div class="muscle-group-section">
        <div class="muscle-group-header">
          <div style="display:flex;align-items:center;gap:var(--sp-sm);">
            <span class="muscle-group-name">${esc(mg.muscleGroup)}</span>
            <span class="badge badge-${mg.priority}">${mg.priority}</span>
            ${mg.soreness ? `<span class="text-sm text-muted">(${mg.soreness})</span>` : ''}
          </div>
          ${session.muscleGroups.length > 1 ? `
            <div class="reorder-btns">
              <button class="reorder-btn" onclick="moveMuscleGroup(${mgIdx},-1)" ${mgIdx === 0 ? 'disabled' : ''} title="Move up">&#9650;</button>
              <button class="reorder-btn" onclick="moveMuscleGroup(${mgIdx},1)" ${mgIdx === session.muscleGroups.length - 1 ? 'disabled' : ''} title="Move down">&#9660;</button>
            </div>
          ` : ''}
        </div>
    `;

    // Group exercises by superset
    const groups = groupExercisesBySupersets(mg.exercises);

    function renderExerciseBlock(ex, exIdx) {
      const swapSuggestion = checkJointPainSwap(ex);
      const libEx = exerciseLib.exercises.find(e => e.id === ex.exerciseId);
      const exNotes = libEx?.notes || '';
      const ssIcon = ex.supersetGroup ? '&#128279;' : '&#9878;';
      const ssTitle = ex.supersetGroup ? 'Manage Superset' : 'Superset';

      let block = `
        <div class="exercise-block">
          <div class="exercise-header">
            <div>
              <div class="exercise-name">${esc(ex.name)}</div>
              <div class="exercise-meta">${ex.sets[0]?.repRange[0]}-${ex.sets[0]?.repRange[1]} reps &middot; Target RPE ${Math.round(ex.sets[0]?.targetRPE || micro.targetRPE)}</div>
              ${exNotes ? `<button class="exercise-notes-toggle has-notes" onclick="toggleWorkoutNotes('${ex.exerciseId}')">&#128221; Notes</button>` : ''}
            </div>
            <div style="display:flex;gap:4px;align-items:center;">
              ${mg.exercises.length > 1 ? `
                <div class="reorder-btns">
                  <button class="reorder-btn" onclick="moveExercise(${mgIdx},${exIdx},-1)" ${exIdx === 0 ? 'disabled' : ''} title="Move up">&#9650;</button>
                  <button class="reorder-btn" onclick="moveExercise(${mgIdx},${exIdx},1)" ${exIdx === mg.exercises.length - 1 ? 'disabled' : ''} title="Move down">&#9660;</button>
                </div>
              ` : ''}
              <button class="btn btn-ghost btn-small" onclick="promptSuperset('${meso.id}',${activeWorkout.microIdx},${activeWorkout.sessionIdx},${mgIdx},${exIdx})" title="${ssTitle}" style="font-size:12px;padding:4px 6px;">${ssIcon}</button>
              <button class="btn btn-ghost btn-small" onclick="editExerciseInSession('${meso.id}',${activeWorkout.microIdx},${activeWorkout.sessionIdx},${mgIdx},${exIdx})">Edit</button>
              <button class="btn btn-ghost btn-small" onclick="addWorkoutSet(${mgIdx},${exIdx})">+Set</button>
            </div>
          </div>
          ${exNotes ? `<div class="exercise-notes-area" id="workout-notes-${ex.exerciseId}" style="display:none;"><textarea placeholder="Exercise notes..." onblur="saveExerciseNotes('${ex.exerciseId}', this.value)">${esc(exNotes)}</textarea></div>` : ''}
      `;

      if (swapSuggestion) {
        block += `
          <div class="swap-suggestion ${swapSuggestion.urgent ? 'urgent' : ''} mb-8">
            ${swapSuggestion.urgent ? '&#9888;' : '&#128161;'} ${swapSuggestion.message}
            <button class="btn btn-secondary btn-small mt-8" onclick="promptExerciseSwap(${mgIdx},${exIdx})">Swap Exercise</button>
          </div>
        `;
      }

      block += `
        <div class="set-row" style="background:none;border:none;padding:2px 8px;">
          <div class="set-num">#</div>
          <div class="set-col"><div class="set-input-label">Type</div></div>
          <div class="set-col" style="width:60px"><div class="set-input-label">Load</div></div>
          <div class="set-col" style="width:60px"><div class="set-input-label">Reps</div></div>
          <div class="set-col" style="width:60px"><div class="set-input-label">RPE</div></div>
          <div class="set-done-wrap"><div class="set-input-label">Done</div></div>
          <div style="width:24px"></div>
        </div>
      `;

      ex.sets.forEach((set, setIdx) => {
        const isDone = set.actualLoad != null;
        const sType = set.setType || 'straight';
        const aboveType = setIdx > 0 ? (ex.sets[setIdx - 1]?.setType || 'straight') : '';
        const canMyoMatch = setIdx > 0 && (aboveType === 'straight' || aboveType === 'myorep_match');
        const isMyoMatch = sType === 'myorep_match';
        const myoParent = isMyoMatch ? resolveMyoParent(ex.sets, setIdx) : null;
        const myoLoad = myoParent ? (myoParent.actualLoad ?? myoParent.targetLoad) : set.targetLoad;
        const myoReps = myoParent ? (myoParent.actualReps ?? myoParent.targetReps) : set.targetReps;
        const displayLoad = isMyoMatch ? myoLoad : (set.actualLoad ?? set.targetLoad);
        const displayReps = isMyoMatch ? myoReps : (set.actualReps ?? set.targetReps);
        const targetLoadDisplay = isMyoMatch ? myoLoad : set.targetLoad;
        const targetRepsDisplay = isMyoMatch ? myoReps : set.targetReps;
        block += `
          <div class="set-row ${isDone ? 'set-completed' : ''}">
            <div class="set-num">${setIdx + 1}</div>
            <div class="set-col">
              <select class="set-type-select" onchange="updateWorkoutSetType(${mgIdx},${exIdx},${setIdx},this.value)">
                <option value="straight" ${sType === 'straight' ? 'selected' : ''}>Str</option>
                <option value="myorep" ${sType === 'myorep' ? 'selected' : ''}>Myo</option>
                ${canMyoMatch ? `<option value="myorep_match" ${isMyoMatch ? 'selected' : ''}>M.M</option>` : ''}
                <option value="giant" ${sType === 'giant' ? 'selected' : ''}>Giant</option>
              </select>
            </div>
            <div class="set-col">
              <input type="number" class="set-input" value="${displayLoad}"
                data-path="${mgIdx}.${exIdx}.${setIdx}.load"
                onchange="updateActual(this)" placeholder="${targetLoadDisplay}" ${isMyoMatch ? 'disabled style="opacity:0.5;"' : ''}>
              <div class="set-target">${targetLoadDisplay}</div>
            </div>
            <div class="set-col">
              <input type="number" class="set-input" value="${displayReps}"
                data-path="${mgIdx}.${exIdx}.${setIdx}.reps"
                onchange="updateActual(this)" placeholder="${targetRepsDisplay}" ${isMyoMatch ? 'disabled style="opacity:0.5;"' : ''}>
              <div class="set-target">${targetRepsDisplay}</div>
            </div>
            <div class="set-col">
              <input type="number" class="set-input" value="${set.actualRPE ?? Math.round(set.targetRPE)}"
                data-path="${mgIdx}.${exIdx}.${setIdx}.rpe"
                onchange="updateActual(this)" placeholder="${Math.round(set.targetRPE)}" step="0.5">
              <div class="set-target">${Math.round(set.targetRPE)}</div>
            </div>
            <div class="set-done-wrap">
              <input type="checkbox" class="set-done-cb" ${isDone ? 'checked' : ''}
                onchange="toggleSetDone(this,${mgIdx},${exIdx},${setIdx})">
            </div>
            <button class="btn-ghost" onclick="removeWorkoutSet(${mgIdx},${exIdx},${setIdx})" style="color:var(--error);font-size:12px;width:24px;padding:0;">&times;</button>
          </div>
        `;
      });

      const allSetsLogged = ex.sets.every(s => s.actualLoad != null);
      if (allSetsLogged && ex._jointPainLogged == null) {
        block += `
          <div class="mt-8">
            <div class="text-sm text-muted mb-4">Joint/connective tissue fatigue for ${esc(ex.name)}?</div>
            <div class="chip-group">
              <div class="chip chip-sm" onclick="logJointPain(${mgIdx},${exIdx},'none')" style="border-color:var(--success);color:var(--success);">None</div>
              <div class="chip chip-sm" onclick="logJointPain(${mgIdx},${exIdx},'meh')" style="border-color:var(--warning);color:var(--warning);">Meh</div>
              <div class="chip chip-sm" onclick="logJointPain(${mgIdx},${exIdx},'ow')" style="border-color:#F97316;color:#F97316;">Ow</div>
              <div class="chip chip-sm" onclick="logJointPain(${mgIdx},${exIdx},'super_ow')" style="border-color:var(--error);color:var(--error);">Super Ow</div>
            </div>
          </div>
        `;
      } else if (ex._jointPainLogged) {
        block += `<div class="text-sm mt-4" style="color:var(--text-muted);">Joint pain: <strong>${ex._jointPainLogged}</strong></div>`;
      }

      block += `</div>`; // exercise-block
      return block;
    }

    groups.forEach(group => {
      if (group.type === 'superset') {
        html += `<div class="superset-group"><div class="superset-label">Superset</div>`;
        group.members.forEach((m, mi) => {
          html += renderExerciseBlock(m.exercise, m.originalIndex);
          if (mi < group.members.length - 1) html += `<div class="superset-divider"></div>`;
        });
        html += `</div>`;
      } else {
        html += renderExerciseBlock(group.exercise, group.originalIndex);
      }
    });

    html += `</div>`; // muscle-group-section
  });

  // Complete session button
  html += `
    <div class="divider"></div>
    <button class="btn btn-success btn-large" onclick="completeSession()">Complete Session &#10003;</button>
    <div class="text-sm text-muted text-center mt-8">This will save your workout and auto-progress the next session.</div>
  `;

  html += '</div>';
  area.innerHTML = html;
}

function exitSession() {
  activeWorkout = null;
  renderWorkout();
}

function needsSorenessPrompt(meso, microIdx, sessionIdx, muscleGroup) {
  // Check if this muscle group appeared in any prior completed session
  for (let mi = 0; mi <= microIdx; mi++) {
    const micro = meso.microcycles[mi];
    const maxSi = mi < microIdx ? micro.sessions.length : sessionIdx;
    for (let si = 0; si < maxSi; si++) {
      const sess = micro.sessions[si];
      if (sess.status === 'completed' && sess.muscleGroups.some(mg => mg.muscleGroup === muscleGroup)) {
        return true;
      }
    }
  }
  return false;
}

function promptSoreness(muscleGroup) {
  showModal(`
    <div class="modal-title">Recovery Check</div>
    <div class="modal-subtitle">How sore are you in <strong>${esc(muscleGroup)}</strong> from your last session?</div>
    <div class="modal-options">
      <div class="modal-opt" onclick="setSoreness('${esc(muscleGroup)}','forever_ago')">&#128526; Forever Ago <div class="text-sm text-muted">Fully recovered, no soreness at all</div></div>
      <div class="modal-opt" onclick="setSoreness('${esc(muscleGroup)}','recently')">&#128528; Recently <div class="text-sm text-muted">Some residual soreness, but manageable</div></div>
      <div class="modal-opt" onclick="setSoreness('${esc(muscleGroup)}','owie')">&#129324; Owie <div class="text-sm text-muted">Still quite sore from last time</div></div>
    </div>
  `);
}

function setSoreness(muscleGroup, level) {
  if (!activeWorkout) return;
  const meso = mesocycles.find(m => m.id === activeWorkout.mesoId);
  const session = meso.microcycles[activeWorkout.microIdx].sessions[activeWorkout.sessionIdx];
  const mg = session.muscleGroups.find(mg => mg.muscleGroup === muscleGroup);
  if (!mg) { closeModal(); return; }
  mg.soreness = level;

  // Apply set progression to CURRENT session based on soreness (§5.3)
  const setsToAdd = progressSets(level, mg.priority);
  if (setsToAdd > 0 && mg.exercises.length > 0) {
    for (let i = 0; i < setsToAdd; i++) {
      const randExIdx = Math.floor(Math.random() * mg.exercises.length);
      const randEx = mg.exercises[randExIdx];
      const lastSet = randEx.sets[randEx.sets.length - 1];
      randEx.sets.push({
        repRange: [...lastSet.repRange],
        targetLoad: lastSet.targetLoad,
        targetReps: lastSet.targetReps,
        targetRPE: lastSet.targetRPE,
        setType: lastSet.setType || 'straight'
      });
    }
    toast(`Added ${setsToAdd} set${setsToAdd > 1 ? 's' : ''} based on recovery`, 'success');
  }

  closeModal();
  saveMesocycles();
  renderWorkout();
}

function updateActual(input) {
  if (!activeWorkout) return;
  const [mgIdx, exIdx, setIdx, field] = input.dataset.path.split('.').map((v, i) => i < 3 ? parseInt(v) : v);
  const meso = mesocycles.find(m => m.id === activeWorkout.mesoId);
  const set = meso.microcycles[activeWorkout.microIdx].sessions[activeWorkout.sessionIdx]
    .muscleGroups[mgIdx].exercises[exIdx].sets[setIdx];
  const val = parseFloat(input.value);
  if (field === 'load') set.actualLoad = val;
  else if (field === 'reps') set.actualReps = val;
  else if (field === 'rpe') set.actualRPE = val;
  saveMesocycles();
}

function toggleSetDone(cb, mgIdx, exIdx, setIdx) {
  if (!activeWorkout) return;
  const meso = mesocycles.find(m => m.id === activeWorkout.mesoId);
  const ex = meso.microcycles[activeWorkout.microIdx].sessions[activeWorkout.sessionIdx]
    .muscleGroups[mgIdx].exercises[exIdx];
  const set = ex.sets[setIdx];

  if (cb.checked) {
    const sType = set.setType || 'straight';
    if (sType === 'myorep_match' && setIdx > 0) {
      // Myorep match: lock to resolved parent's actual values
      const parent = resolveMyoParent(ex.sets, setIdx);
      set.actualLoad = parent.actualLoad ?? parent.targetLoad;
      set.actualReps = parent.actualReps ?? parent.targetReps;
      // Only RPE is editable for myorep_match
      const row = cb.closest('.set-row');
      const rpeInput = row.querySelectorAll('.set-input:not([disabled])');
      set.actualRPE = parseFloat(rpeInput[0]?.value) || set.targetRPE;
    } else {
      // Stamp current input values as actuals (reads from the DOM inputs in this row)
      const row = cb.closest('.set-row');
      const inputs = row.querySelectorAll('.set-input');
      set.actualLoad = parseFloat(inputs[0].value) || set.targetLoad;
      set.actualReps = parseFloat(inputs[1].value) || set.targetReps;
      set.actualRPE = parseFloat(inputs[2].value) || set.targetRPE;
    }
  } else {
    // Unchecking: clear actuals
    delete set.actualLoad;
    delete set.actualReps;
    delete set.actualRPE;
  }
  saveMesocycles();
  renderWorkout();
}

function updateWorkoutSetType(mgIdx, exIdx, setIdx, val) {
  if (!activeWorkout) return;
  const meso = mesocycles.find(m => m.id === activeWorkout.mesoId);
  const ex = meso.microcycles[activeWorkout.microIdx].sessions[activeWorkout.sessionIdx]
    .muscleGroups[mgIdx].exercises[exIdx];
  ex.sets[setIdx].setType = val;
  // If changing to a type that can't parent a myorep_match, reset any below
  if (val !== 'straight' && val !== 'myorep_match') {
    for (let i = setIdx + 1; i < ex.sets.length; i++) {
      if (ex.sets[i].setType === 'myorep_match') ex.sets[i].setType = 'straight';
      else break;
    }
  }
  // If setting to myorep_match, sync targets with resolved parent
  if (val === 'myorep_match' && setIdx > 0) {
    const parent = resolveMyoParent(ex.sets, setIdx);
    ex.sets[setIdx].targetLoad = parent.actualLoad ?? parent.targetLoad;
    ex.sets[setIdx].targetReps = parent.actualReps ?? parent.targetReps;
    // Clear actuals since values changed
    delete ex.sets[setIdx].actualLoad;
    delete ex.sets[setIdx].actualReps;
    delete ex.sets[setIdx].actualRPE;
  }
  saveMesocycles();
  renderWorkout();
}

function addWorkoutSet(mgIdx, exIdx) {
  if (!activeWorkout) return;
  const meso = mesocycles.find(m => m.id === activeWorkout.mesoId);
  const ex = meso.microcycles[activeWorkout.microIdx].sessions[activeWorkout.sessionIdx]
    .muscleGroups[mgIdx].exercises[exIdx];
  const lastSet = ex.sets[ex.sets.length - 1];
  ex.sets.push({
    repRange: [...lastSet.repRange],
    targetLoad: lastSet.targetLoad,
    targetReps: lastSet.targetReps,
    targetRPE: lastSet.targetRPE,
    setType: lastSet.setType || 'straight'
  });
  saveMesocycles();
  renderWorkout();
}

function removeWorkoutSet(mgIdx, exIdx, setIdx) {
  if (!activeWorkout) return;
  const meso = mesocycles.find(m => m.id === activeWorkout.mesoId);
  const ex = meso.microcycles[activeWorkout.microIdx].sessions[activeWorkout.sessionIdx]
    .muscleGroups[mgIdx].exercises[exIdx];
  if (ex.sets.length <= 1) { toast('Need at least 1 set'); return; }
  ex.sets.splice(setIdx, 1);
  saveMesocycles();
  renderWorkout();
}

function logJointPain(mgIdx, exIdx, level) {
  if (!activeWorkout) return;
  const meso = mesocycles.find(m => m.id === activeWorkout.mesoId);
  const ex = meso.microcycles[activeWorkout.microIdx].sessions[activeWorkout.sessionIdx]
    .muscleGroups[mgIdx].exercises[exIdx];
  ex._jointPainLogged = level;
  ex.jointPainHistory.push(level);
  saveMesocycles();
  renderWorkout();
}

function moveExercise(mgIdx, exIdx, direction) {
  if (!activeWorkout) return;
  const meso = mesocycles.find(m => m.id === activeWorkout.mesoId);
  const exercises = meso.microcycles[activeWorkout.microIdx].sessions[activeWorkout.sessionIdx]
    .muscleGroups[mgIdx].exercises;
  const targetIdx = exIdx + direction;
  if (targetIdx < 0 || targetIdx >= exercises.length) return;
  [exercises[exIdx], exercises[targetIdx]] = [exercises[targetIdx], exercises[exIdx]];
  saveMesocycles();
  renderWorkout();
}

function moveMuscleGroup(mgIdx, direction) {
  if (!activeWorkout) return;
  const meso = mesocycles.find(m => m.id === activeWorkout.mesoId);
  const muscleGroups = meso.microcycles[activeWorkout.microIdx].sessions[activeWorkout.sessionIdx].muscleGroups;
  const targetIdx = mgIdx + direction;
  if (targetIdx < 0 || targetIdx >= muscleGroups.length) return;
  [muscleGroups[mgIdx], muscleGroups[targetIdx]] = [muscleGroups[targetIdx], muscleGroups[mgIdx]];
  saveMesocycles();
  renderWorkout();
}

function checkJointPainSwap(ex) {
  const hist = ex.jointPainHistory || [];
  if (hist.length === 0) return null;

  // Super Ow: 2 of last 3
  const last3 = hist.slice(-3);
  const superOwCount = last3.filter(h => h === 'super_ow').length;
  if (superOwCount >= 2) {
    return { urgent: true, message: `Serious joint pain detected! ${ex.name} has caused "Super Ow" ${superOwCount} of the last ${last3.length} sessions. Strongly recommend swapping this exercise.` };
  }

  // Ow: 2 of last 5
  const last5 = hist.slice(-5);
  const owCount = last5.filter(h => h === 'ow' || h === 'super_ow').length;
  if (owCount >= 2) {
    return { urgent: false, message: `Joint discomfort trend: ${ex.name} has caused pain ${owCount} of the last ${last5.length} sessions. Consider swapping.` };
  }

  // Meh: 6 of last 10
  const last10 = hist.slice(-10);
  const mehCount = last10.filter(h => h === 'meh' || h === 'ow' || h === 'super_ow').length;
  if (mehCount >= 6) {
    return { urgent: false, message: `Minor joint irritation adding up: ${mehCount} of last ${last10.length} sessions had some discomfort. Worth considering a swap.` };
  }

  return null;
}

function promptExerciseSwap(mgIdx, exIdx) {
  if (!activeWorkout) return;
  const meso = mesocycles.find(m => m.id === activeWorkout.mesoId);
  const mg = meso.microcycles[activeWorkout.microIdx].sessions[activeWorkout.sessionIdx].muscleGroups[mgIdx];
  const ex = mg.exercises[exIdx];
  const available = getExercisesForGroup(mg.muscleGroup).filter(e =>
    e.id !== ex.exerciseId && !mg.exercises.find(x => x.exerciseId === e.id)
  );

  let optionsHtml = available.map(e =>
    `<div class="modal-opt" onclick="swapExercise(${mgIdx},${exIdx},'${e.id}')">${esc(e.name)}</div>`
  ).join('');

  if (available.length === 0) {
    optionsHtml = `<div class="text-muted text-center">No other exercises available for ${mg.muscleGroup}. Add more in the Exercises tab.</div>`;
  }

  showModal(`
    <div class="modal-title">Swap Exercise</div>
    <div class="modal-subtitle">Replace <strong>${esc(ex.name)}</strong> with:</div>
    <div class="modal-options">${optionsHtml}</div>
    <button class="btn btn-ghost mt-12" onclick="closeModal()" style="width:100%">Cancel</button>
  `);
}

function swapExercise(mgIdx, exIdx, newExId) {
  if (!activeWorkout) return;
  const meso = mesocycles.find(m => m.id === activeWorkout.mesoId);
  const mg = meso.microcycles[activeWorkout.microIdx].sessions[activeWorkout.sessionIdx].muscleGroups[mgIdx];
  const oldEx = mg.exercises[exIdx];
  const newExData = exerciseLib.exercises.find(e => e.id === newExId);
  if (!newExData) return;

  mg.exercises[exIdx] = {
    exerciseId: newExData.id,
    name: newExData.name,
    muscleGroup: newExData.muscleGroup,
    supersetGroup: oldEx.supersetGroup || null,
    jointPainHistory: [],
    sets: oldEx.sets.map(s => ({
      repRange: [...s.repRange],
      targetLoad: s.targetLoad,
      targetReps: s.targetReps,
      targetRPE: s.targetRPE,
      setType: s.setType || 'straight'
    }))
  };

  closeModal();
  saveMesocycles();
  toast(`Swapped to ${newExData.name}`, 'success');
  renderWorkout();
}

// ============================================================
// PROGRESSION ENGINE
// ============================================================
function classifyPerformance(exercise) {
  // Average across sets
  const sets = exercise.sets.filter(s => s.actualLoad != null);
  if (sets.length === 0) return 'matched';

  let totalLoadDiff = 0, totalRepsDiff = 0, totalRIRDiff = 0;
  sets.forEach(s => {
    totalLoadDiff += (s.actualLoad || 0) - (s.targetLoad || 0);
    totalRepsDiff += (s.actualReps || 0) - (s.targetReps || 0);
    // RIR = inverse of RPE. Higher RIR means easier. target RPE 8 = target RIR 2
    // actual RPE 7 = actual RIR 3 → RIR diff = +1 (better than expected)
    const targetRIR = 10 - (s.targetRPE || 8);
    const actualRIR = 10 - (s.actualRPE || 8);
    totalRIRDiff += actualRIR - targetRIR;
  });

  const n = sets.length;
  const avgLoadDiff = totalLoadDiff / n;
  const avgRepsDiff = totalRepsDiff / n;
  const avgRIRDiff = totalRIRDiff / n;

  // Classify each dimension: 1 = Higher, 0 = Equal, -1 = Lower
  const loadCat = Math.abs(avgLoadDiff) <= 1 ? 0 : (avgLoadDiff > 0 ? 1 : -1);
  const repsCat = Math.abs(avgRepsDiff) <= 0.4 ? 0 : (avgRepsDiff > 0 ? 1 : -1);
  const rirCat = Math.abs(avgRIRDiff) <= 0.4 ? 0 : (avgRIRDiff > 0 ? 1 : -1);

  // Exceeded: E/E/H, E/H/H, H/H/H (§2.1)
  if ((loadCat === 0 && repsCat === 0 && rirCat === 1) ||
      (loadCat === 0 && repsCat === 1 && rirCat === 1) ||
      (loadCat === 1 && repsCat === 1 && rirCat === 1)) return 'exceeded';

  // Below: L/E/E, L/L/E, L/L/L (§2.3)
  if ((loadCat === -1 && repsCat === 0 && rirCat === 0) ||
      (loadCat === -1 && repsCat === -1 && rirCat === 0) ||
      (loadCat === -1 && repsCat === -1 && rirCat === -1)) return 'below';

  // Matched: E/E/E and all unclassified combos (§2.4)
  return 'matched';
}

function progressExercise(exercise, priority, microTargetRPE, prevPerformances) {
  // Clone sets for the next session — always start from TARGETS (§3: below repeats targets)
  const newSets = exercise.sets.map((s, sIdx) => {
    const type = s.setType || 'straight';
    const base = {
      repRange: [...s.repRange],
      targetLoad: s.targetLoad,
      targetReps: s.targetReps,
      targetRPE: microTargetRPE,
      setType: type
    };
    // Myorep match: inherit from resolved parent
    if (type === 'myorep_match' && sIdx > 0) {
      const parent = resolveMyoParent(exercise.sets, sIdx);
      if (parent) {
        base.targetLoad = parent.targetLoad;
        base.targetReps = parent.targetReps;
      }
    }
    return base;
  });

  const perf = classifyPerformance(exercise);

  if (perf === 'below') {
    // Below: targets are already carried forward from previous targets (not actuals)
    // Sync myorep_match with resolved parent
    newSets.forEach((s, i) => {
      if (i > 0 && (s.setType || 'straight') === 'myorep_match') {
        const parent = resolveMyoParent(newSets, i);
        if (parent) { s.targetLoad = parent.targetLoad; s.targetReps = parent.targetReps; }
      }
    });

    const belowCount = countConsecutiveBelow(prevPerformances);
    if (belowCount >= 3) {
      // FORCED deload (§3.1.1): reduce load by 10%, reset reps
      newSets.forEach(s => {
        const st = s.setType || 'straight';
        if (st === 'myorep_match') return;
        if (st !== 'giant') s.targetLoad = roundTo5(s.targetLoad * 0.9);
        s.targetReps = s.repRange[0];
      });
      newSets.forEach((s, i) => {
        if (i > 0 && (s.setType || 'straight') === 'myorep_match') {
          const parent = resolveMyoParent(newSets, i);
          if (parent) { s.targetLoad = parent.targetLoad; s.targetReps = parent.targetReps; }
        }
      });
      return { sets: newSets, perf, deload: 'forced' };
    }
    if (belowCount >= 2) {
      // SUGGESTED deload (§3.1.1): keep targets, flag for dismissable UI
      return { sets: newSets, perf, deload: 'suggested' };
    }
    return { sets: newSets, perf, deload: null };
  }

  // Helper: progress a single set with load increase (or cap for giant sets)
  function progressSet(s, addReps, loadMultiplier) {
    // Myorep match sets inherit from set 0, skip individual progression
    if ((s.setType || 'straight') === 'myorep_match') return;
    const newReps = s.targetReps + addReps;
    if (newReps <= s.repRange[1]) {
      s.targetReps = newReps;
    } else if ((s.setType || 'straight') === 'giant') {
      // Giant sets: never increase load, cap reps at top of range
      s.targetReps = s.repRange[1];
    } else {
      s.targetLoad = roundTo5(s.targetLoad * loadMultiplier);
      s.targetReps = s.repRange[0];
    }
  }

  if (priority === 'primary') {
    if (perf === 'exceeded') {
      // +2 reps to first progressable set, +1 to rest (§3.1.1)
      let firstProgressed = false;
      newSets.forEach(s => {
        if ((s.setType || 'straight') === 'myorep_match') return;
        progressSet(s, firstProgressed ? 1 : 2, 1.03);
        firstProgressed = true;
      });
    } else {
      // Matched: +1 rep all sets
      newSets.forEach(s => progressSet(s, 1, 1.025));
    }
  } else {
    // Secondary and Maintenance: same logic for exceeded & matched
    newSets.forEach(s => progressSet(s, 1, 1.025));
  }

  // Sync myorep_match sets with resolved parent after progression
  newSets.forEach((s, i) => {
    if (i > 0 && (s.setType || 'straight') === 'myorep_match') {
      const parent = resolveMyoParent(newSets, i);
      if (parent) { s.targetLoad = parent.targetLoad; s.targetReps = parent.targetReps; }
    }
  });

  return { sets: newSets, perf, deload: null };
}

function countConsecutiveBelow(prevPerformances) {
  let count = 0;
  for (let i = prevPerformances.length - 1; i >= 0; i--) {
    if (prevPerformances[i] === 'below') count++;
    else break;
  }
  return count;
}

function progressSets(soreness, priority) {
  // Set progression based on soreness x priority
  // Returns how many sets to add
  if (priority === 'maintenance') return 0;

  if (soreness === 'owie' || !soreness) return 0;

  if (priority === 'primary') {
    if (soreness === 'recently') return 1;
    if (soreness === 'forever_ago') return 2;
  }

  if (priority === 'secondary') {
    if (soreness === 'recently') return 0;
    if (soreness === 'forever_ago') return 1;
  }

  return 0;
}

function getRPEForPriority(priority, startingRPE, weekNumber) {
  // Calculate target RPE based on priority and week number
  // Week 1 uses startingRPE, each subsequent week adds the increment
  const weeksElapsed = weekNumber - 1;
  if (priority === 'primary') return Math.min(10, startingRPE + weeksElapsed * 0.75);
  if (priority === 'secondary') return Math.min(10, startingRPE + weeksElapsed * 0.25);
  return 7; // Maintenance holds at 7
}

function getPreviousPerformances(meso, exerciseId, upToMicroIdx, upToSessionIdx) {
  const perfs = [];
  for (let mi = 0; mi <= upToMicroIdx; mi++) {
    const micro = meso.microcycles[mi];
    if (!micro) break;
    for (let si = 0; si < micro.sessions.length; si++) {
      if (mi === upToMicroIdx && si >= upToSessionIdx) break;
      const session = micro.sessions[si];
      if (session.status !== 'completed') continue;
      session.muscleGroups.forEach(mg => {
        mg.exercises.forEach(ex => {
          if (ex.exerciseId === exerciseId) {
            perfs.push(classifyPerformance(ex));
          }
        });
      });
    }
  }
  return perfs;
}

function generateNextMicrocycle(meso, completedMicroIdx) {
  const completedMicro = meso.microcycles[completedMicroIdx];
  const nextWeekNum = completedMicro.weekNumber + 1;

  // Build new sessions based on completed ones
  const newSessions = completedMicro.sessions.map(session => {
    const newMGs = session.muscleGroups.map(mg => {
      const nextRPE = getRPEForPriority(mg.priority, meso.startingRPE, nextWeekNum);

      // Soreness-based set progression now happens at session start (§5.3),
      // not during next microcycle generation

      const newExercises = mg.exercises.map(ex => {
        const prevPerfs = getPreviousPerformances(meso, ex.exerciseId, completedMicroIdx + 1, 0);
        prevPerfs.push(classifyPerformance(ex));
        const result = progressExercise(ex, mg.priority, nextRPE, prevPerfs);

        return {
          exerciseId: ex.exerciseId,
          name: ex.name,
          muscleGroup: ex.muscleGroup,
          supersetGroup: ex.supersetGroup || null,
          jointPainHistory: [...ex.jointPainHistory],
          sets: result.sets,
          _lastPerf: result.perf,
          _deload: result.deload
        };
      });

      return {
        muscleGroup: mg.muscleGroup,
        priority: mg.priority,
        soreness: null, // Reset for next week
        exercises: newExercises
      };
    });

    return {
      id: uid(),
      dayLabel: session.dayLabel,
      muscleGroups: newMGs,
      status: 'upcoming',
      completedAt: null
    };
  });

  // Calculate target RPE for display (using primary RPE progression as the headline number)
  const nextTargetRPE = getRPEForPriority('primary', meso.startingRPE, nextWeekNum);

  return {
    id: uid(),
    weekNumber: nextWeekNum,
    targetRPE: parseFloat(nextTargetRPE.toFixed(2)),
    sessions: newSessions,
    status: 'active'
  };
}

async function completeSession() {
  if (!activeWorkout) return;
  const meso = mesocycles.find(m => m.id === activeWorkout.mesoId);
  const { microIdx, sessionIdx } = activeWorkout;
  const session = meso.microcycles[microIdx].sessions[sessionIdx];

  // Verify all sets have actuals
  let incomplete = false;
  session.muscleGroups.forEach(mg => {
    mg.exercises.forEach(ex => {
      ex.sets.forEach(s => {
        if (s.actualLoad == null) incomplete = true;
      });
    });
  });

  if (incomplete) {
    showModal(`
      <div class="modal-title">Incomplete Session</div>
      <div class="modal-subtitle">Some sets don't have actual values logged. Complete anyway?</div>
      <div class="modal-options">
        <div class="modal-opt" onclick="forceCompleteSession()">Complete Anyway</div>
        <div class="modal-opt" onclick="closeModal()">Go Back</div>
      </div>
    `);
    return;
  }

  await doCompleteSession();
}

async function forceCompleteSession() {
  closeModal();
  await doCompleteSession();
}

async function doCompleteSession() {
  const meso = mesocycles.find(m => m.id === activeWorkout.mesoId);
  const { microIdx, sessionIdx } = activeWorkout;
  const micro = meso.microcycles[microIdx];
  const session = micro.sessions[sessionIdx];

  // Guard: prevent double-completion
  if (session.status === 'completed') {
    toast('Session already completed', 'warning');
    activeWorkout = null;
    renderWorkout();
    return;
  }

  // Fill in any missing actuals with targets
  session.muscleGroups.forEach(mg => {
    mg.exercises.forEach(ex => {
      ex.sets.forEach(s => {
        if (s.actualLoad == null) s.actualLoad = s.targetLoad;
        if (s.actualReps == null) s.actualReps = s.targetReps;
        if (s.actualRPE == null) s.actualRPE = s.targetRPE;
      });
    });
  });

  session.status = 'completed';
  session.completedAt = new Date().toISOString();

  // Save to history
  history.push({
    mesoId: meso.id,
    mesoName: meso.name,
    weekNumber: micro.weekNumber,
    sessionLabel: session.dayLabel,
    completedAt: session.completedAt,
    muscleGroups: JSON.parse(JSON.stringify(session.muscleGroups))
  });

  // Check if all sessions in this microcycle are complete
  const allSessionsDone = micro.sessions.every(s => s.status === 'completed');
  if (allSessionsDone) {
    micro.status = 'completed';

    // Generate next microcycle (guard against duplicates)
    const nextMicro = generateNextMicrocycle(meso, microIdx);
    const existingNext = meso.microcycles.find(mc => mc.weekNumber === nextMicro.weekNumber);
    if (!existingNext) {
      meso.microcycles.push(nextMicro);

      // Check for deload warnings
      let hasForcedDeload = false;
      let hasSuggestedDeload = false;
      nextMicro.sessions.forEach(s => {
        s.muscleGroups.forEach(mg => {
          mg.exercises.forEach(ex => {
            if (ex._deload === 'forced') hasForcedDeload = true;
            if (ex._deload === 'suggested') hasSuggestedDeload = true;
          });
        });
      });

      if (hasForcedDeload) {
        toast('Deload forced for some exercises next week — load reduced 10%', 'error');
      } else if (hasSuggestedDeload) {
        toast(`Week ${micro.weekNumber} complete! Deload suggested for some exercises.`, 'warning');
      } else {
        toast(`Week ${micro.weekNumber} complete! Week ${nextMicro.weekNumber} generated.`, 'success');
      }
    } else {
      toast(`Week ${micro.weekNumber} complete!`, 'success');
    }
  } else {
    toast('Session complete!', 'success');
  }

  await Promise.all([saveMesocycles(), saveHistory()]);
  activeWorkout = null;
  renderWorkout();
}

async function completeMesocycle(mesoId) {
  const meso = mesocycles.find(m => m.id === mesoId);
  if (!meso) return;
  meso.status = 'completed';
  await saveMesocycles();
  activeMesoId = null;
  toast('Mesocycle completed!', 'success');
  switchTab('dashboard');
}

// ============================================================
// CRUD EDITING
// ============================================================
function editMesocycle(mesoId) {
  const meso = mesocycles.find(m => m.id === mesoId); if (!meso) return;
  showModal(`<div class="modal-title">Edit Mesocycle</div><div class="modal-scroll"><div class="form-group"><label>Name</label><input type="text" id="edit-meso-name" value="${esc(meso.name)}"></div><div class="form-group"><label>Starting RPE</label><input type="number" id="edit-meso-rpe" value="${meso.startingRPE}" min="5" max="10" step="0.5" style="max-width:120px;text-align:center;"></div><div class="form-group"><label>Status</label><select id="edit-meso-status"><option value="active" ${meso.status === 'active' ? 'selected' : ''}>Active</option><option value="completed" ${meso.status === 'completed' ? 'selected' : ''}>Completed</option></select></div><div class="btn-row"><button class="btn btn-danger btn-small" onclick="deleteMesocycle('${meso.id}')">Delete</button><button class="btn btn-secondary" onclick="closeModal()">Cancel</button><button class="btn btn-primary" onclick="saveMesocycleEdit('${meso.id}')" style="flex:2">Save</button></div></div>`);
}
async function saveMesocycleEdit(mesoId) {
  const meso = mesocycles.find(m => m.id === mesoId); if (!meso) return;
  const name = document.getElementById('edit-meso-name').value.trim();
  if (!name) { toast('Name is required'); return; }
  const rpe = parseFloat(document.getElementById('edit-meso-rpe').value) || meso.startingRPE;
  const status = document.getElementById('edit-meso-status').value;
  if (status === 'active' && meso.status !== 'active') { mesocycles.forEach(m => { if (m.status === 'active') m.status = 'completed'; }); }
  meso.name = name; meso.startingRPE = rpe; meso.status = status;
  await saveMesocycles(); closeModal(); toast('Mesocycle updated', 'success'); renderCurrentTab();
}
async function deleteMesocycle(mesoId) {
  showModal(`<div class="modal-title">Delete Mesocycle?</div><div class="modal-subtitle">This will permanently delete this mesocycle and all its data. This cannot be undone.</div><div class="btn-row"><button class="btn btn-secondary" onclick="editMesocycle('${mesoId}')">Cancel</button><button class="btn btn-danger" onclick="confirmDeleteMesocycle('${mesoId}')" style="flex:2">Delete Forever</button></div>`);
}
async function confirmDeleteMesocycle(mesoId) {
  mesocycles = mesocycles.filter(m => m.id !== mesoId);
  if (activeMesoId === mesoId) activeMesoId = null;
  if (activeWorkout && activeWorkout.mesoId === mesoId) activeWorkout = null;
  await saveMesocycles(); closeModal(); toast('Mesocycle deleted', 'success'); switchTab('dashboard');
}
function editSession(mesoId, microIdx, sessionIdx) {
  const meso = mesocycles.find(m => m.id === mesoId); if (!meso) return;
  const session = meso.microcycles[microIdx].sessions[sessionIdx];
  const allGroups = getMuscleGroups();
  const assignedGroups = session.muscleGroups.map(mg => mg.muscleGroup);
  let mgHtml = '';
  session.muscleGroups.forEach((mg, gi) => {
    let exHtml = '';
    mg.exercises.forEach((ex, ei) => {
      const ssIcon = ex.supersetGroup ? '&#128279;' : '&#9878;';
      const ssColor = ex.supersetGroup ? 'color:var(--accent-primary);' : '';
      exHtml += `<div class="flex-between" style="padding:4px 0;font-size:13px;"><span>${esc(ex.name)}${ex.supersetGroup ? ' <span style="font-size:10px;color:var(--accent-primary);">SS</span>' : ''}</span><div class="edit-item-actions"><button class="edit-btn" onclick="promptSuperset('${mesoId}',${microIdx},${sessionIdx},${gi},${ei})" title="Superset" style="${ssColor}">${ssIcon}</button><button class="edit-btn" onclick="editExerciseInSession('${mesoId}',${microIdx},${sessionIdx},${gi},${ei})" title="Edit">&#9998;</button><button class="edit-btn" style="color:var(--error);" onclick="removeExerciseFromSession('${mesoId}',${microIdx},${sessionIdx},${gi},${ei})" title="Remove">&times;</button></div></div>`;
    });
    const available = getExercisesForGroup(mg.muscleGroup).filter(a => !mg.exercises.find(e => e.exerciseId === a.id));
    mgHtml += `<div class="edit-item"><div class="flex-between mb-8"><span style="font-weight:600;">${esc(mg.muscleGroup)}</span><div class="edit-item-actions"><div class="priority-select"><div class="priority-opt ${mg.priority === 'primary' ? 'sel-primary' : ''}" onclick="setEditGroupPriority('${mesoId}',${microIdx},${sessionIdx},${gi},'primary')">P</div><div class="priority-opt ${mg.priority === 'secondary' ? 'sel-secondary' : ''}" onclick="setEditGroupPriority('${mesoId}',${microIdx},${sessionIdx},${gi},'secondary')">S</div><div class="priority-opt ${mg.priority === 'maintenance' ? 'sel-maintenance' : ''}" onclick="setEditGroupPriority('${mesoId}',${microIdx},${sessionIdx},${gi},'maintenance')">M</div></div><button class="edit-btn" style="color:var(--error);" onclick="removeGroupFromSession('${mesoId}',${microIdx},${sessionIdx},${gi})" title="Remove group">&times;</button></div></div>${exHtml}${available.length > 0 ? `<select onchange="addExerciseToSession('${mesoId}',${microIdx},${sessionIdx},${gi},this.value);this.value='';" style="font-size:12px;padding:6px 8px;margin-top:6px;"><option value="">+ Add exercise...</option>${available.map(e => `<option value="${e.id}">${esc(e.name)}</option>`).join('')}</select>` : ''}</div>`;
  });
  const unassignedGroups = allGroups.filter(g => !assignedGroups.includes(g));
  showModal(`<div class="modal-title">Edit Session</div><div class="modal-scroll"><div class="form-group"><label>Session Name</label><input type="text" id="edit-session-name" value="${esc(session.dayLabel)}"></div><div class="form-group"><label>Muscle Groups</label>${mgHtml}${unassignedGroups.length > 0 ? `<div class="chip-group mt-8" style="flex-wrap:wrap;">${unassignedGroups.map(g => `<div class="chip chip-sm" onclick="addGroupToSession('${mesoId}',${microIdx},${sessionIdx},'${g.replace(/'/g, "\\\\'")}')">${esc(g)}</div>`).join('')}</div>` : ''}</div><div class="btn-row"><button class="btn btn-danger btn-small" onclick="deleteSession('${mesoId}',${microIdx},${sessionIdx})">Delete Session</button><button class="btn btn-secondary" onclick="closeModal()">Cancel</button><button class="btn btn-primary" onclick="saveSessionEdit('${mesoId}',${microIdx},${sessionIdx})" style="flex:2">Save</button></div></div>`);
}
async function saveSessionEdit(mesoId, microIdx, sessionIdx) {
  const meso = mesocycles.find(m => m.id === mesoId); if (!meso) return;
  const session = meso.microcycles[microIdx].sessions[sessionIdx];
  const name = document.getElementById('edit-session-name').value.trim();
  if (!name) { toast('Session name is required'); return; }
  const oldLabel = session.dayLabel;
  meso.microcycles.forEach(mc => { const s = mc.sessions[sessionIdx]; if (s && s.dayLabel === oldLabel) s.dayLabel = name; });
  session.dayLabel = name;
  await saveMesocycles(); closeModal(); toast('Session updated', 'success'); renderCurrentTab();
}
function setEditGroupPriority(mesoId, microIdx, sessionIdx, gi, priority) {
  const meso = mesocycles.find(m => m.id === mesoId); if (!meso) return;
  meso.microcycles[microIdx].sessions[sessionIdx].muscleGroups[gi].priority = priority;
  saveMesocycles(); editSession(mesoId, microIdx, sessionIdx);
}
function addGroupToSession(mesoId, microIdx, sessionIdx, group) {
  const meso = mesocycles.find(m => m.id === mesoId); if (!meso) return;
  meso.microcycles[microIdx].sessions[sessionIdx].muscleGroups.push({ muscleGroup: group, priority: 'primary', soreness: null, exercises: [] });
  saveMesocycles(); editSession(mesoId, microIdx, sessionIdx);
}
function removeGroupFromSession(mesoId, microIdx, sessionIdx, gi) {
  const meso = mesocycles.find(m => m.id === mesoId); if (!meso) return;
  meso.microcycles[microIdx].sessions[sessionIdx].muscleGroups.splice(gi, 1);
  saveMesocycles(); editSession(mesoId, microIdx, sessionIdx);
}
function addExerciseToSession(mesoId, microIdx, sessionIdx, gi, exId) {
  if (!exId) return; const meso = mesocycles.find(m => m.id === mesoId); if (!meso) return;
  const ex = exerciseLib.exercises.find(e => e.id === exId); if (!ex) return;
  const micro = meso.microcycles[microIdx];
  meso.microcycles[microIdx].sessions[sessionIdx].muscleGroups[gi].exercises.push({ exerciseId: ex.id, name: ex.name, muscleGroup: ex.muscleGroup, supersetGroup: null, jointPainHistory: [], sets: [{ repRange: [8, 12], targetLoad: 0, targetReps: 8, targetRPE: micro.targetRPE, setType: 'straight' }] });
  saveMesocycles(); editSession(mesoId, microIdx, sessionIdx);
}
function removeExerciseFromSession(mesoId, microIdx, sessionIdx, gi, ei) {
  const meso = mesocycles.find(m => m.id === mesoId); if (!meso) return;
  meso.microcycles[microIdx].sessions[sessionIdx].muscleGroups[gi].exercises.splice(ei, 1);
  saveMesocycles(); editSession(mesoId, microIdx, sessionIdx);
}
async function deleteSession(mesoId, microIdx, sessionIdx) {
  showModal(`<div class="modal-title">Delete Session?</div><div class="modal-subtitle">This will remove this session from the current week.</div><div class="btn-row"><button class="btn btn-secondary" onclick="editSession('${mesoId}',${microIdx},${sessionIdx})">Cancel</button><button class="btn btn-danger" onclick="confirmDeleteSession('${mesoId}',${microIdx},${sessionIdx})" style="flex:2">Delete</button></div>`);
}
async function confirmDeleteSession(mesoId, microIdx, sessionIdx) {
  const meso = mesocycles.find(m => m.id === mesoId); if (!meso) return;
  meso.microcycles[microIdx].sessions.splice(sessionIdx, 1);
  if (activeWorkout && activeWorkout.mesoId === mesoId && activeWorkout.microIdx === microIdx && activeWorkout.sessionIdx === sessionIdx) { activeWorkout = null; }
  await saveMesocycles(); closeModal(); toast('Session deleted', 'success'); renderCurrentTab();
}
function editExerciseInSession(mesoId, microIdx, sessionIdx, gi, ei) {
  const meso = mesocycles.find(m => m.id === mesoId); if (!meso) return;
  const mg = meso.microcycles[microIdx].sessions[sessionIdx].muscleGroups[gi]; const ex = mg.exercises[ei];
  const available = getExercisesForGroup(mg.muscleGroup).filter(e => e.id !== ex.exerciseId && !mg.exercises.find(x => x.exerciseId === e.id));
  let setsHtml = '';
  ex.sets.forEach((set, setIdx) => {
    const sType = set.setType || 'straight';
    setsHtml += `<div class="set-row"><div class="set-num">${setIdx + 1}</div><div class="set-col"><div class="set-input-label">Type</div><select class="set-type-select" id="edit-set-type-${setIdx}"><option value="straight" ${sType === 'straight' ? 'selected' : ''}>Straight</option><option value="myorep" ${sType === 'myorep' ? 'selected' : ''}>Myorep</option><option value="myorep_match" ${sType === 'myorep_match' ? 'selected' : ''}>Myo Match</option><option value="giant" ${sType === 'giant' ? 'selected' : ''}>Giant</option></select></div><div class="set-col"><div class="set-input-label">Reps</div><div style="display:flex;gap:4px;align-items:center;"><input type="number" class="set-input" style="width:45px;" id="edit-set-rmin-${setIdx}" value="${set.repRange[0]}"><span style="color:var(--text-muted);">-</span><input type="number" class="set-input" style="width:45px;" id="edit-set-rmax-${setIdx}" value="${set.repRange[1]}"></div></div><div class="set-col"><div class="set-input-label">Load</div><input type="number" class="set-input" id="edit-set-load-${setIdx}" value="${set.targetLoad}"></div><button class="edit-btn" style="color:var(--error);" onclick="removeSetFromEdit('${mesoId}',${microIdx},${sessionIdx},${gi},${ei},${setIdx})">&times;</button></div>`;
  });
  showModal(`<div class="modal-title">Edit Exercise</div><div class="modal-scroll"><div class="form-group"><label>Exercise</label><select id="edit-ex-swap"><option value="${ex.exerciseId}">${esc(ex.name)}</option>${available.map(e => `<option value="${e.id}">${esc(e.name)}</option>`).join('')}</select></div><div class="form-group"><label>Sets</label>${setsHtml}<button class="btn btn-ghost mt-8" onclick="addSetToEdit('${mesoId}',${microIdx},${sessionIdx},${gi},${ei})">+ Add Set</button></div><div class="btn-row"><button class="btn btn-secondary" onclick="editSession('${mesoId}',${microIdx},${sessionIdx})">Back</button><button class="btn btn-primary" onclick="saveExerciseEdit('${mesoId}',${microIdx},${sessionIdx},${gi},${ei})" style="flex:2">Save</button></div></div>`);
}
function addSetToEdit(mesoId, microIdx, sessionIdx, gi, ei) {
  const meso = mesocycles.find(m => m.id === mesoId); if (!meso) return;
  const ex = meso.microcycles[microIdx].sessions[sessionIdx].muscleGroups[gi].exercises[ei];
  const lastSet = ex.sets[ex.sets.length - 1] || { repRange: [8, 12], targetLoad: 0, targetReps: 8, targetRPE: meso.microcycles[microIdx].targetRPE, setType: 'straight' };
  ex.sets.push({ repRange: [...lastSet.repRange], targetLoad: lastSet.targetLoad, targetReps: lastSet.targetReps, targetRPE: lastSet.targetRPE, setType: lastSet.setType || 'straight' });
  saveMesocycles(); editExerciseInSession(mesoId, microIdx, sessionIdx, gi, ei);
}
function removeSetFromEdit(mesoId, microIdx, sessionIdx, gi, ei, setIdx) {
  const meso = mesocycles.find(m => m.id === mesoId); if (!meso) return;
  const ex = meso.microcycles[microIdx].sessions[sessionIdx].muscleGroups[gi].exercises[ei];
  if (ex.sets.length <= 1) { toast('Need at least 1 set'); return; }
  ex.sets.splice(setIdx, 1); saveMesocycles(); editExerciseInSession(mesoId, microIdx, sessionIdx, gi, ei);
}
async function saveExerciseEdit(mesoId, microIdx, sessionIdx, gi, ei) {
  const meso = mesocycles.find(m => m.id === mesoId); if (!meso) return;
  const mg = meso.microcycles[microIdx].sessions[sessionIdx].muscleGroups[gi]; const ex = mg.exercises[ei];
  const newExId = document.getElementById('edit-ex-swap').value;
  if (newExId !== ex.exerciseId) { const nd = exerciseLib.exercises.find(e => e.id === newExId); if (nd) { ex.exerciseId = nd.id; ex.name = nd.name; ex.muscleGroup = nd.muscleGroup; ex.jointPainHistory = []; } }
  ex.sets.forEach((set, si) => {
    const t = document.getElementById(`edit-set-type-${si}`), rn = document.getElementById(`edit-set-rmin-${si}`), rx = document.getElementById(`edit-set-rmax-${si}`), l = document.getElementById(`edit-set-load-${si}`);
    if (t) set.setType = t.value; if (rn) set.repRange[0] = parseInt(rn.value) || set.repRange[0]; if (rx) set.repRange[1] = parseInt(rx.value) || set.repRange[1]; if (l) set.targetLoad = parseFloat(l.value) || set.targetLoad;
    set.targetReps = set.repRange[0];
  });
  await saveMesocycles(); closeModal(); toast('Exercise updated', 'success'); renderCurrentTab();
}
function addSessionToMicrocycle(mesoId, microIdx) {
  const meso = mesocycles.find(m => m.id === mesoId); if (!meso) return;
  const n = meso.microcycles[microIdx].sessions.length + 1;
  meso.microcycles[microIdx].sessions.push({ id: uid(), dayLabel: `Day ${n}`, muscleGroups: [], status: 'upcoming', completedAt: null });
  saveMesocycles(); editSession(mesoId, microIdx, meso.microcycles[microIdx].sessions.length - 1); renderCurrentTab();
}

// ============================================================
// HISTORY & STATS
// ============================================================
function renderHistory() {
  const area = document.getElementById('tab-history');

  if (history.length === 0) {
    area.innerHTML = `
      <div class="empty-state fade-in">
        <div class="empty-icon">&#128200;</div>
        <div class="empty-title">No History Yet</div>
        <div class="empty-text">Complete your first workout to see performance data here.</div>
      </div>
    `;
    return;
  }

  if (historyExercise) {
    renderExerciseHistory(area);
    return;
  }

  let html = '<div class="fade-in">';
  html += `<div class="wizard-title mb-16">History & Stats</div>`;

  // Show muscle groups with exercise drill-down
  const groupMap = {};
  history.forEach(h => {
    h.muscleGroups.forEach(mg => {
      if (!groupMap[mg.muscleGroup]) groupMap[mg.muscleGroup] = {};
      mg.exercises.forEach(ex => {
        if (!groupMap[mg.muscleGroup][ex.exerciseId]) {
          groupMap[mg.muscleGroup][ex.exerciseId] = { name: ex.name, sessions: 0 };
        }
        groupMap[mg.muscleGroup][ex.exerciseId].sessions++;
      });
    });
  });

  Object.keys(groupMap).sort().forEach(group => {
    html += `<div class="card mb-12"><div class="card-header mb-8">${esc(group)}</div>`;
    Object.entries(groupMap[group]).forEach(([exId, data]) => {
      html += `
        <div class="card-clickable" style="padding:10px 0;border-bottom:1px solid var(--border-color);cursor:pointer;" onclick="viewExerciseHistory('${exId}')">
          <div class="flex-between">
            <span style="font-size:14px;">${esc(data.name)}</span>
            <span class="text-sm text-muted">${data.sessions} sessions</span>
          </div>
        </div>
      `;
    });
    html += `</div>`;
  });

  // Recent sessions
  html += `<div class="card-header mb-8 mt-16">Recent Sessions</div>`;
  const recent = [...history].reverse().slice(0, 10);
  recent.forEach(h => {
    const groups = h.muscleGroups.map(mg => mg.muscleGroup).join(', ');
    html += `
      <div class="card mb-8">
        <div class="flex-between">
          <div>
            <div style="font-weight:600;font-size:14px;">${esc(h.sessionLabel)}</div>
            <div class="text-sm text-muted">${esc(h.mesoName)} &middot; Week ${h.weekNumber}</div>
          </div>
          <div class="text-sm text-muted">${new Date(h.completedAt).toLocaleDateString()}</div>
        </div>
        <div class="text-sm text-muted mt-4">${esc(groups)}</div>
      </div>
    `;
  });

  html += '</div>';
  area.innerHTML = html;
}

function viewExerciseHistory(exId) {
  historyExercise = exId;
  renderHistory();
}

function renderExerciseHistory(area) {
  const exId = historyExercise;

  // Gather all sessions with this exercise
  const sessions = [];
  history.forEach(h => {
    h.muscleGroups.forEach(mg => {
      mg.exercises.forEach(ex => {
        if (ex.exerciseId === exId) {
          sessions.push({
            date: h.completedAt,
            week: h.weekNumber,
            mesoName: h.mesoName,
            sets: ex.sets,
            perf: classifyPerformance(ex)
          });
        }
      });
    });
  });

  if (sessions.length === 0) {
    historyExercise = null;
    renderHistory();
    return;
  }

  const exName = sessions[0].sets.length > 0 ?
    (exerciseLib.exercises.find(e => e.id === exId)?.name || exId) : exId;

  let html = '<div class="fade-in">';
  html += `
    <button class="btn btn-ghost mb-12" onclick="historyExercise=null; renderHistory()">&larr; Back to History</button>
    <div class="wizard-title mb-4">${esc(exName)}</div>
    <div class="text-sm text-muted mb-16">${sessions.length} sessions logged</div>
  `;

  // Chart
  const labels = sessions.map((s, i) => `W${s.week}`);
  const avgLoads = sessions.map(s => {
    const loggedSets = s.sets.filter(st => st.actualLoad != null);
    if (loggedSets.length === 0) return 0;
    return loggedSets.reduce((sum, st) => sum + (st.actualLoad || 0), 0) / loggedSets.length;
  });
  const avgReps = sessions.map(s => {
    const loggedSets = s.sets.filter(st => st.actualReps != null);
    if (loggedSets.length === 0) return 0;
    return loggedSets.reduce((sum, st) => sum + (st.actualReps || 0), 0) / loggedSets.length;
  });
  const volume = sessions.map(s => {
    return s.sets.reduce((sum, st) => sum + ((st.actualLoad || 0) * (st.actualReps || 0)), 0);
  });

  html += `<div class="chart-container"><canvas id="history-chart"></canvas></div>`;

  // Performance badges
  html += `<div class="stat-row mb-16">`;
  const exceeded = sessions.filter(s => s.perf === 'exceeded').length;
  const matched = sessions.filter(s => s.perf === 'matched').length;
  const below = sessions.filter(s => s.perf === 'below').length;
  html += `
    <div class="stat-badge"><div class="stat-value" style="color:var(--success);">${exceeded}</div><div class="stat-label">Exceeded</div></div>
    <div class="stat-badge"><div class="stat-value" style="color:var(--accent-primary);">${matched}</div><div class="stat-label">Matched</div></div>
    <div class="stat-badge"><div class="stat-value" style="color:var(--error);">${below}</div><div class="stat-label">Below</div></div>
  `;
  html += `</div>`;

  // Session list
  sessions.reverse().forEach(s => {
    const perfBadge = s.perf === 'exceeded' ? 'badge-secondary' : s.perf === 'matched' ? 'badge-primary' : 'badge-danger';
    html += `
      <div class="card mb-8">
        <div class="flex-between mb-4">
          <div class="text-sm text-muted">${esc(s.mesoName)} &middot; Week ${s.week}</div>
          <span class="badge ${perfBadge}">${s.perf}</span>
        </div>
        ${s.sets.map((st, i) => {
          const sType = st.setType || 'straight';
          const typeLabel = sType !== 'straight' ? `<span class="set-type-badge ${sType}">${({myorep:'Myo',myorep_match:'M.M',giant:'Giant',straight:''})[sType]}</span> ` : '';
          return `<div class="text-sm" style="padding:2px 0;color:var(--text-secondary);">
            Set ${i+1}: ${typeLabel}${st.actualLoad || st.targetLoad}lbs &times; ${st.actualReps || st.targetReps} @ RPE ${Math.round(st.actualRPE || st.targetRPE)}
          </div>`;
        }).join('')}
      </div>
    `;
  });

  html += '</div>';
  area.innerHTML = html;

  // Render chart after DOM update
  setTimeout(() => {
    const canvas = document.getElementById('history-chart');
    if (!canvas) return;
    new Chart(canvas, {
      type: 'line',
      data: {
        labels,
        datasets: [
          {
            label: 'Avg Load (lbs)',
            data: avgLoads,
            borderColor: getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim() || '#D97757',
            backgroundColor: 'rgba(' + (getComputedStyle(document.documentElement).getPropertyValue('--accent-r').trim() || '217') + ',' + (getComputedStyle(document.documentElement).getPropertyValue('--accent-g').trim() || '119') + ',' + (getComputedStyle(document.documentElement).getPropertyValue('--accent-b').trim() || '87') + ',0.1)',
            tension: 0.3, fill: true, yAxisID: 'y'
          },
          {
            label: 'Volume (load×reps)',
            data: volume,
            borderColor: '#10B981',
            backgroundColor: 'rgba(16,185,129,0.1)',
            tension: 0.3, fill: true, yAxisID: 'y1'
          }
        ]
      },
      options: {
        responsive: true, maintainAspectRatio: false,
        plugins: { legend: { labels: { color: '#9CA3AF', font: { size: 11 } } } },
        scales: {
          x: { ticks: { color: '#9CA3AF' }, grid: { color: '#E8E6E3' } },
          y: { position: 'left', ticks: { color: getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim() || '#D97757' }, grid: { color: '#E8E6E3' }, title: { display: true, text: 'Load', color: getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim() || '#D97757' } },
          y1: { position: 'right', ticks: { color: '#10B981' }, grid: { display: false }, title: { display: true, text: 'Volume', color: '#10B981' } }
        }
      }
    });
  }, 50);
}

// ============================================================
// EXERCISE LIBRARY
// ============================================================
let exerciseSearch = '';

function renderExercises() {
  const area = document.getElementById('tab-exercises');
  const groups = getMuscleGroups();

  let html = '<div class="fade-in">';
  html += `<div class="wizard-title mb-16">Exercise Library</div>`;

  // Search
  html += `
    <div class="search-wrap mb-16">
      <span class="search-icon">&#128269;</span>
      <input type="text" id="exercise-search" placeholder="Search exercises..." value="${esc(exerciseSearch)}"
        oninput="exerciseSearch=this.value; renderExercises()">
    </div>
  `;

  // Add new exercise
  html += `
    <div class="card mb-16">
      <div class="card-header mb-8">Add Exercise</div>
      <div class="form-row">
        <div class="form-group" style="flex:2">
          <input type="text" id="new-exercise-name" placeholder="Exercise name">
        </div>
        <div class="form-group" style="flex:1">
          <select id="new-exercise-group" onchange="document.getElementById('custom-group-wrap').classList.toggle('hidden', this.value !== '__custom')">
            ${groups.map(g => `<option value="${esc(g)}">${esc(g)}</option>`).join('')}
            <option value="__custom">+ Custom Group</option>
          </select>
        </div>
      </div>
      <div id="custom-group-wrap" class="form-group hidden">
        <input type="text" id="new-exercise-custom-group" placeholder="New muscle group name">
      </div>
      <button class="btn btn-primary" onclick="addExerciseToLib()">Add Exercise</button>
    </div>
  `;

  // Grouped list
  const filtered = exerciseLib.exercises.filter(e =>
    !exerciseSearch || e.name.toLowerCase().includes(exerciseSearch.toLowerCase()) || e.muscleGroup.toLowerCase().includes(exerciseSearch.toLowerCase())
  );

  const grouped = {};
  filtered.forEach(e => {
    if (!grouped[e.muscleGroup]) grouped[e.muscleGroup] = [];
    grouped[e.muscleGroup].push(e);
  });

  Object.keys(grouped).sort().forEach(group => {
    html += `<div class="card mb-12"><div class="card-header mb-8">${esc(group)} <span class="text-sm text-muted">(${grouped[group].length})</span></div>`;
    grouped[group].forEach(e => {
      const hasNotes = e.notes && e.notes.trim();
      html += `
        <div style="padding:6px 0;border-bottom:1px solid rgba(156,163,175,0.13);">
          <div class="flex-between">
            <span style="font-size:14px;">${esc(e.name)}</span>
            <div style="display:flex;align-items:center;gap:4px;">
              <button class="exercise-notes-toggle ${hasNotes ? 'has-notes' : ''}" onclick="toggleLibNotes('${e.id}')">&#128221; ${hasNotes ? 'Notes' : 'Add note'}</button>
              <button class="btn-ghost" onclick="deleteExercise('${e.id}')" style="color:var(--error);font-size:12px;">&times;</button>
            </div>
          </div>
          <div class="exercise-notes-area" id="lib-notes-${e.id}" style="display:none;">
            <textarea placeholder="Cues, observations, reminders..." onblur="saveExerciseNotes('${e.id}', this.value)">${esc(e.notes || '')}</textarea>
          </div>
        </div>
      `;
    });
    html += `</div>`;
  });

  if (filtered.length === 0) {
    html += `<div class="text-muted text-center">No exercises found.</div>`;
  }

  html += '</div>';
  area.innerHTML = html;
}

async function addExerciseToLib() {
  const name = document.getElementById('new-exercise-name').value.trim();
  let group = document.getElementById('new-exercise-group').value;
  if (group === '__custom') {
    group = document.getElementById('new-exercise-custom-group').value.trim();
    if (!group) { toast('Enter a muscle group name'); return; }
  }
  if (!name) { toast('Enter an exercise name'); return; }

  exerciseLib.exercises.push({ id: uid(), name, muscleGroup: group, notes: '' });
  await saveExercises();
  toast(`Added ${name}`, 'success');
  renderExercises();
}

async function deleteExercise(id) {
  exerciseLib.exercises = exerciseLib.exercises.filter(e => e.id !== id);
  await saveExercises();
  toast('Exercise removed', 'success');
  renderExercises();
}

function toggleLibNotes(exId) {
  const el = document.getElementById('lib-notes-' + exId);
  if (!el) return;
  const show = el.style.display === 'none';
  el.style.display = show ? 'block' : 'none';
  if (show) { const ta = el.querySelector('textarea'); if (ta) ta.focus(); }
}

function toggleWorkoutNotes(exId) {
  const el = document.getElementById('workout-notes-' + exId);
  if (!el) return;
  const show = el.style.display === 'none';
  el.style.display = show ? 'block' : 'none';
  if (show) { const ta = el.querySelector('textarea'); if (ta) ta.focus(); }
}

async function saveExerciseNotes(exId, value) {
  const ex = exerciseLib.exercises.find(e => e.id === exId);
  if (!ex) return;
  if (ex.notes === value) return;
  ex.notes = value;
  await saveExercises();
}

// ============================================================
// UTILITY
// ============================================================
function esc(str) {
  if (str == null) return '';
  return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

// ============================================================
// DATA MIGRATION — recompute stale progression after logic fixes
// ============================================================
function migrateStaleProgression() {
  let changed = false;
  mesocycles.forEach(meso => {
    // Skip if this meso was already migrated
    if (meso._migrationVersion >= 1) return;
    meso._migrationVersion = 1;
    changed = true;

    // Step 1: Deduplicate microcycles with same weekNumber
    const seen = new Map();
    const toRemove = [];

    meso.microcycles.forEach((mc, i) => {
      const key = mc.weekNumber;
      if (seen.has(key)) {
        const existingIdx = seen.get(key);
        const existingMc = meso.microcycles[existingIdx];
        const existingCompleted = existingMc.sessions.filter(s => s.status === 'completed').length;
        const thisCompleted = mc.sessions.filter(s => s.status === 'completed').length;
        if (thisCompleted > existingCompleted) {
          toRemove.push(existingIdx);
          seen.set(key, i);
        } else {
          toRemove.push(i);
        }
      } else {
        seen.set(key, i);
      }
    });

    if (toRemove.length > 0) {
      toRemove.sort((a, b) => b - a).forEach(idx => meso.microcycles.splice(idx, 1));
      changed = true;
    }

    // Step 2: Recompute _lastPerf/_deload for upcoming exercises in generated microcycles
    meso.microcycles.forEach((micro, microIdx) => {
      if (microIdx === 0) return;
      const sourceMicro = meso.microcycles[microIdx - 1];
      if (!sourceMicro || sourceMicro.status !== 'completed') return;

      micro.sessions.forEach((session, sessionIdx) => {
        if (session.status === 'completed') return;
        const sourceSession = sourceMicro.sessions[sessionIdx];
        if (!sourceSession) return;

        session.muscleGroups.forEach(mg => {
          mg.exercises.forEach(ex => {
            let sourceEx = null;
            sourceSession.muscleGroups.forEach(smg => {
              smg.exercises.forEach(se => {
                if (se.exerciseId === ex.exerciseId) sourceEx = se;
              });
            });
            if (!sourceEx) return;

            const prevPerfs = getPreviousPerformances(meso, ex.exerciseId, microIdx, 0);
            prevPerfs.push(classifyPerformance(sourceEx));
            const nextRPE = getRPEForPriority(mg.priority, meso.startingRPE, micro.weekNumber);
            const result = progressExercise(sourceEx, mg.priority, nextRPE, prevPerfs);

            ex._lastPerf = result.perf;
            ex._deload = result.deload;
            ex.sets = result.sets;
          });
        });
      });
    });
  });
  return changed;
}

// ============================================================
// INIT
// ============================================================
async function init() {
  await loadAll();
  if (migrateStaleProgression()) {
    await saveMesocycles();
  }
  renderDashboard();
}

init();
</script>
<script>
// === CACHE-BUSTING SERVICE WORKER ===
// Bump this version string whenever index.html is updated.
// The SW will purge old caches and force a reload.
const APP_VERSION = '2026-02-18f';

if ('serviceWorker' in navigator) {
  const swCode = `
    const CACHE_NAME = 'hypertrophy-v${APP_VERSION}';
    self.addEventListener('install', e => {
      self.skipWaiting();
    });
    self.addEventListener('activate', e => {
      e.waitUntil(
        caches.keys().then(keys =>
          Promise.all(keys.filter(k => k !== CACHE_NAME).map(k => caches.delete(k)))
        ).then(() => self.clients.claim())
      );
    });
    self.addEventListener('fetch', e => {
      // Network-first: always try the network, only fall back to cache
      e.respondWith(
        fetch(e.request).then(resp => {
          if (resp.ok) {
            const clone = resp.clone();
            caches.open(CACHE_NAME).then(c => c.put(e.request, clone));
          }
          return resp;
        }).catch(() => caches.match(e.request))
      );
    });
  `;
  const swBlob = new Blob([swCode], { type: 'application/javascript' });
  const swURL = URL.createObjectURL(swBlob);

  navigator.serviceWorker.register(swURL, { scope: location.pathname })
    .then(reg => {
      // Check for updates periodically
      setInterval(() => reg.update().catch(() => {}), 60 * 1000);
    })
    .catch(() => {
      // blob: SW registration may fail on some browsers — that's fine,
      // the meta tags above still help with caching.
    });

  // Reload when a new service worker takes over
  let refreshing = false;
  navigator.serviceWorker.addEventListener('controllerchange', () => {
    if (!refreshing) { refreshing = true; location.reload(); }
  });
}
</script>
</body>
</html>
